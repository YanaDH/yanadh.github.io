[{"title":"git worktree 依赖隔离、多分支开发图文详解","url":"/2023/01/11/git-worktree/","content":"\n1 前言\n2 常用命令\n3 图文详解\n4 注意事项\n\n1 前言\n今天做项目开发时，发现切换分支后，有一个功能就会有问题，原因是因为两个分支的依赖项不一致，导致每次切换分支时都需要 npm install 一下，那有没有什么办法能做到依赖隔离呢？\n我们切换分支开发时，若有不想提交的代码，一般是使用 git stash 暂存起来，然后 git checkout ，开发完成后再使用 git stash pop 将暂存取出来继续开发。但是 git checkout 的开发都是基于同一个文件进行修改，而 node_modules 都会被记录到 .gitignore 文件下进行 git 忽略，所以不会被 git stash 暂存上，如果有依赖变化，切换分支之后 node_modules 使用的是上一个分支的最新依赖，可能会导致原分支上的功能不可用。\n使用 git worktree 可以做到依赖隔离，且只需要维护一个仓库，又可以同时在多个分支上进行工作\n\n2 常用命令2.1 查看所有 worktreegit clone 一个项目之后，都会有一个默认的 worktree\ngit worktree list\n\n2.2 添加 worktreegit worktree add 路径名\n\ngit worktree add test\n\n在当前目录下新增一个 test 文件夹\ntest 文件夹的内容为当前分支的克隆文件\n默认新增一个 test 分支\n\ngit worktree add ../test\n\n在上一层级目录下新增一个 test 文件夹\ntest 文件夹的内容为当前分支的克隆文件\n默认新增一个 test 分支\n\ngit worktree add 路径名 -b 新分支名\ngit worktree add test -b dev\n\n在当前目录下新增一个 test 文件夹\ntest 文件夹的内容为当前分支的克隆文件\n新增一个 dev 分支\n\ngit worktree add 路径名 -b 新分支名 远程分支名\ngit worktree add test -b dev origin/dev\n\n在当前目录下新增一个 test 文件夹\ntest 文件夹的内容为远程分支 origin&#x2F;dev 的克隆文件\n新增一个 dev 分支\n\n2.3 移除 worktreegit worktree remove 工作树名\ngit worktree remove test\n\n2.4 清洁 worktreegit worktree prune\n\n3 图文详解\nvscode 打开 commitTest 文件夹，此时本地分支为 master 分支，在该分支上安装了一个 moment 包\n新增一个名为 test 的 worktree新生成的 test 文件夹下自动 clone 与本地 master 分支一样的内容（有eslint，但没有上一步在本地 master 分支上安装的 moment，只会 clone 已经 commit 的内容）\n为了方便比较， 重新打开一个 vscode ，打开文件夹为 test 文件夹安装 axios 包，并新增一个 txt 文件，此时， test 文件夹下的 node_modules 有 axios ，但没有 moment\ncommitTest 文件夹下的 node_modules 只有 moment ， 没有 axios ， 依赖已隔离\n可正常执行 git add 、 git commit 、 git push 等操作\n远程仓库上新增了 test 分支， package.json 记录的安装包为 eslint 和 axios ，与本地 worktree 一致\n执行 git worktree remove test ， test 文件夹将被删除，但 test 分支会被保留\n\n4 注意事项\n当前 worktree 使用完后，记得执行 git worktree remove ，避免文件越来越多占用磁盘内存\n建议新增 worktree 后， vscode 打开 worktree 新增的文件夹进行开发，否则没有修改内容对比\n若本地存在与新增 worktree 同名分支，会 clone 与本地同名分支的内容\n\n\n执行 git worktree add 路径名，默认生成与路径名同名的新分支\n若本地没有同名分支，则 clone 内容为当前分支的克隆文件\n若本地有同名分支，则 clone 内容为同名分支的克隆文件\n\n在 master 分支上执行以下命令，新增一个名为 clone 本地分支\ngit worktree add clonegit worktree remove clonegit checkout dev\n在 dev 分支上执行以下命令， copy 与 clone 文件夹下的内容不同\ngit worktree add copygit worktree add clone\n\n","categories":["技术"],"tags":["Git"]},{"title":"Node.js 入门 —— 前后端的身份认证","url":"/2023/01/05/node-identity-authentication/","content":"\n1 前言\n2 Web 开发模式\n3 身份认证\n\n1 前言本文内容来自bilibili 黑马程序员\n2 Web 开发模式2.1 基于服务端渲染的传统 Web 开发模式优点：\n\n前端耗时少，因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电。\n有利于 SEO ，因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于 SEO。缺点：\n占用服务器端资源。即服务器端完成 HTML 页面内容的拼接，如果请求较多会对服务器造成一定的访问压力。\n不利于前后端分高，开发效率低。使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于项目高效开发。\n\n2.2 基于前后端分离的新型 Web 开发模式优点：\n\n开发体验好，前端专注于 U 页面的开发，后端专注于api 的开发，且前端有更多的选择性。\n用户体脸好， Ajax 技术的广泛应用，极大的提高了用户的体验，可以经松实现页面的局部刷新，\n减轻了服务器端的渲染压力，因为页面最终是在每个用户的浏览器中生成的。缺点：不利于 SEO。因为完整的 HTML 页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。（解决方案：利用 Vue、 React 等前端框架的 SSR (server side render) 技术能够很好的解决 SEO 问题！）\n\n3 身份认证3.1 什么是身份认证\n身份认证 (Authentication）又称“身份验证”、“鉴杈”，是指通过一定的手段，完成对用户身份的确认\n在Web 开发中，也涉及到用户身份的认证，例如：各大网站的手机验证码登录、邮箱密码登录、二维码登录等\n\n3.2 不同模式下的身份认证\n服务端渲染推荐使用 Session 认证机制\n前后端分离推荐使用 JWT 认证机制\n\n3.3 Session 认证机制3.3.1 什么是 Cookie\nCookie 是存储在用户浏览器中的一段不超过 4KB 的字符串，它由一个名称(Name)、一个值(Value)和其他几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成\n不同域名下的 Cookie 是相互独立的，每当客户端发起请求时，会自动把当前域名下所有未过期的 Cookie 一同发给服务器端\n\nCookie 的几大特性：\n\n自动发送\n域名独立\n过期时限\n4KB 限制\n\n3.3.2 Cookie 在身份认证中的作用\n客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的 Cookie ，客户端会自动将 Cookie 保存在浏览器中。\n随后，当客户端刘览器每次请求服务器的时候，浏览器会自动将身份认证相关的 Cookie ，通过请求头的形式发送给服务器，服务器即可验明客户端的身份。\n\n\n","categories":["技术"],"tags":["Node"]},{"title":"Node.js 入门 —— 数据库","url":"/2023/01/05/node-database/","content":"\n1 前言\n2 数据库的基本概念\n3 mysql 的基本使用\n\n1 前言本文内容来自bilibili 黑马程序员\n2 数据库的基本概念2.1 什么是数据库\n数据库(database)是用来组织、存储和管理数据的仓库\n当今世界是一个充满着数据的互联网世界，充斥着大量的数据。数据的来源有很多，比如出行记录、消费记录，浏览的网页、发送的消息等等。除了文本类型的数据，图像、音乐、声音都足数据\n为了方便管理互联网世界中的数据，就有了数据库管理系统的概念 （简称：数据库)。用户可以对数据库中的数据进行新增、查询、更新、删除等操作\n\n2.2 常见的数据库及分类市面上的数据库有很多种，最常见的数据库有如下几个：\n\nMysQL 数据库 （目前使用最广泛、流行度最高的开源免费数据库；Community + Enterprise)\nOracle 数据库（收费）\nSQL Server 数据库（收费）\nMongodb 数据库 (Community + Enterprise)\n\n其中，MysQL、 Oracle、 SQL Server 属于传统型数据库 （又叫做：关系型数据库 或 SQL 数据库），这三者的设计理念相同，用法比较类似。而 Mongodb 属于新型数据库 (又叫做：非关系型数据库 或 NoSQL 数据库），它在一定程度上弥补了传统型数据库的缺陷。\n2.3 传统型数据库的数据组织结构在传统型数据库中，数据的组织结构分为数据库(database)、数据表(table)、数据行(row)和字段(field)这4个部分组成\n\n在实际项目开发中，一般情况下，每个项目都对应独立的数据库\n不同的数据，要存储到数据库的不同表中，例如：用户数据存储到 users 表中，图书数据存储到 books 表中\n每个表中具体存储哪些信息，由字段来决定，例如：我们可以为 users 表设计 id 、 uername 、 password 这3个字段\n表中的行，代表每一条具体的数据\n\n3 mysql 的基本使用3.1 什么是 SQLSQL（英文全称：Structured Query Language）是结构化查询语言，专门用来访问和处理数据库的编程语言。能够让我们以编程的形式，操作数据库里面的数据\n\nSQL是一门数据库编程语言\n使用 SQL 语言编写出来的代码，叫做 SQL 语句SQL语言只能在关系型数据库中使用（例如 MysQL Oracle. SQl Server)，非关系型数据库（例如 Mongodb)不支持 SQL 语言\n\n3.2 SQL 能做什么\n从数据库中查询数据\n向数据库中插入新的数据\n更新数据库中的数据\n从数据库删除数捃\n可以创建新数据库\n可在数据库中创建新表\n可在数据库中创建存储过程、视图\netc…\n\n3.3 SQL 的学习目标\n重点掌握如何使用 SQL 从数据表中：查询数据(select)、插入数据(insert into)、更新数据(update)、删除数据(delete)\n额外需要掌握 4 中语法：where 条件、 and 和 or 运算符、 order by 排序、 count(*)函数\n\n3.3.1 SELECT 语句SELECT 语句用于从数据表中查询数据，执行结果被存储在一个结果表（结果集）中\nSELECT * FROM 表名SELECT 列名 FROM 表名\n\n3.3.2 INSERT INTO 语句INSERT INTO 语句用于向数据表中插入新的数据行\nINSERT INTO 表名(列1, 列2, ...) VALUES (值1, 值2, ...)\n\n3.3.3 UPDATE 语句UPDATE 语句用于更新数据表某一行中的某一列\nUPDATE 表名 SET 列1=&#x27;值1&#x27; WHERE 列名=&#x27;值&#x27;UPDATE 表名 SET 列1=&#x27;值1&#x27;, 列2=&#x27;值2&#x27; WHERE 列名=&#x27;值&#x27;\n\n3.3.4 DELETE 语句DELETE 语句用于更新数据表某一行中的某一列\nDELETE FROM 表名 WHERE 列名=&#x27;值&#x27;\n\n4 在项目中操作 MySQL\n安装操作 MySQL 数据库的第三方模块(mysql)\n通过 mysql 模块连接到 MySQL 数据库\n通过 mysql 模块执行 SQL 语句\n\nnpm i mysql\n\nconst mysql = require(&#x27;mysql&#x27;)// 通过 mysql 模块连接到 MySQL 数据库const db = mysql.createPool(&#123;  host: &#x27;&#x27;, // 数据库的 IP 地址  user: &#x27;&#x27;, // 登录数据库的账号  password: &#x27;&#x27;, // 登录数据库的密码  database: &#x27;&#x27; // 指定要操作哪个数据库&#125;)\n\n4.1 查询数据db.query(&#x27;SELECT * FROM users&#x27;, (err ,res) =&gt; &#123;  if(err) return console.log(err.message);  console.log(res);&#125;)\n\n4.2 插入数据// 向 user 表中新增一条数据const user = &#123;  username: &#x27;zs&#x27;,  password: &#x27;zs&#x27;&#125;// 定义待执行的 SQL 语句const sql = &#x27;INSERT INTO users (username, password) VALUES(?, ?)&#x27;// 执行 SQL 语句db.query(sql, [user.username, user.password], (err, res) =&gt; &#123;  if(err) return console.log(&#x27;执行 SQL 语句失败了&#x27;)  if(res.affectedRows === 1) console.log(&#x27;插入数据成功&#x27;);&#125;)\n\n便捷方式\nconst user = &#123;  username: &#x27;ls&#x27;,  password: &#x27;ls&#x27;&#125;const sql = &#x27;INSERT INTO users SET ?&#x27;db.query(sql, user, (err, res) =&gt; &#123;  if(err) return console.log(&#x27;执行 SQL 语句失败了&#x27;)  if(res.affectedRows === 1) console.log(&#x27;插入数据成功&#x27;);&#125;)\n\n4.3 更新数据const user = &#123;  id: 20,  username: &#x27;ls&#x27;,  password: &#x27;ls&#x27;&#125;const sql = &#x27;UPDATE users SET username=?, password=? WHERE id=?&#x27;db.query(sql, [user.username, user.password, user.id], (err, res) =&gt; &#123;  if (err) return console.log(&#x27;执行 SQL 语句失败了&#x27;)  if (res.affectedRows === 1) console.log(&#x27;更新数据成功&#x27;);&#125;)\n\n便捷方式\nconst user = &#123;  id: 19,  username: &#x27;ls&#x27;,  password: &#x27;ls&#x27;&#125;const sql = &#x27;UPDATE users SET ? WHERE id=?&#x27;db.query(sql, [user, user.id], (err, res) =&gt; &#123;  if (err) return console.log(&#x27;执行 SQL 语句失败了&#x27;)  if (res.affectedRows === 1) console.log(&#x27;更新数据成功&#x27;);&#125;)\n\n4.4 删除数据const sql = &#x27;DELETE FROM users WHERE id=?&#x27;db.query(sql, 20, (err, res) =&gt; &#123;  if (err) return console.log(&#x27;执行 SQL 语句失败了&#x27;)  if (res.affectedRows === 1) console.log(&#x27;删除数据成功&#x27;);&#125;)\n\n标记删除：使用 DELETE 语句，会把真正的把数据从表中删除掉。为了保险起见，推荐使用标记删除的形式，来模拟删除的动作。所谓的标记删除，就是在表中设置类似于 status 这样的状态字段，来标记当前这条数据是否被删除。当用户执行了删除的动作时，我们并没有执行 DELETE 语句把数据删除掉，而是执行了 UPDATE 语句，将这条数据对应的 status 字段标记为删除即可。\n\nconst sql = &#x27;UPDATE users SET status=? WHERE id=?&#x27;db.query(sql, [1, 21], (err, res) =&gt; &#123;  if (err) return console.log(&#x27;执行 SQL 语句失败了&#x27;)  if (res.affectedRows === 1) console.log(&#x27;标记删除数据成功&#x27;);&#125;)\n","categories":["技术"],"tags":["Node"]},{"title":"Node.js 入门 —— 使用 Express 编写接口","url":"/2023/01/03/node-interface/","content":"\n1 前言\n2 创建基本的服务器\n3 编写接口\n4 cors 资源跨域共享\n5 jsonp 接口\n\n1 前言本文内容来自bilibili 黑马程序员\n2 创建基本的服务器const express = require(&#x27;express&#x27;)const router = require(&#x27;./apiRouter&#x27;)const app = express()app.use(express.json())app.use(express.urlencoded(&#123; extended: false &#125;))app.use(&#x27;/api&#x27;, router)app.listen(80, () =&gt; &#123;  console.log(&#x27;http://127.0.0.1&#x27;);&#125;)\n\n3 编写接口apiRouter.js\nconst express = require(&#x27;express&#x27;)const router = express.Router()// GET 请求router.get(&#x27;/get&#x27;, (req, res) =&gt; &#123;  const query = req.query  res.send(&#123;    status: 0,    message: &#x27;GET 请求成功&#x27;,    data: query  &#125;)&#125;)// POST 请求router.post(&#x27;/post&#x27;, (req, res) =&gt; &#123;  const body = req.body  res.send(&#123;    status: 0,    message: &#x27;POST 请求成功&#x27;,    data: body  &#125;)&#125;)module.exports = router\n\n4 cors 资源跨域共享4.1. 接口的跨域问题解決接口跨域问题的方案主要有两种：\n\nCORS （主流的解决方案，推荐使用）\nJSONP（有缺陷的解决方案：只支持 GET 请求）\n\n4.2 使用 cors 中间件解决跨域问题cors 是 Express 的一个第三方中间件。通过安装和配置 cors 中间件，可以很方便地解决跨域问题。使用步骤分为如下3步：\n\n运行 npm install cors 安装中间件\n使用 const cors &#x3D; require(‘cors’) 导入中间件\n在路由之前调用 app.use(cors()） 配置中间件\n\n4.3 什么是 CORSCORS (Cross-Origin Resource Sharing，跨域资源共享）由一系列 HTTP 响应头组成，这些 HTTP 响应头决定浏览器是否阻止前端 JS 代码跨域获资源。浏览器的同源安全策略默认会阻止网页”跨域”获取资源，但如果接口服务器配置了 CORS 相关的 HTTP 响应头，就可以解除浏览器端的跨域访问限制。\n4.4 CORS 响应头\nAccess-Control-Allow-Origin: 允许访问该资源的URLres.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;http://www.baidu.com&#x27;)res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;)\nAccess-Control-Allow-Headers: 允许发送额外响应头\n\n\n默认情况下，CORS 仅支持客户端向服务器发送如下的9个请求头：Accept, Accept-Language, Content-Language, DPR, Downlink, Save-Data, Viewport-Width, Width, Content-Type（值仅限于 text&#x2F;plain、multipart&#x2F;form-data、application&#x2F;x-www-form-urlencoded 三者之一）\n如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;Request-Id&#x27;)\n\n\nAccess-Control-Allow-Methods: 允许的 HTTP 方法\n\n\n默认情况下，CORS 仅支持客户端发起 GET POST. HEAD 请求\n如果客户端希望通过 PUT、 DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Allow-Methods 来指明实际请求所允许使用的 HTTP 方法// 只许 POST、GET、DELETE、HEAD 请求方法res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;POST, GET, DELETE, HEAD&#x27;)// 允许所有的 HTTP 请求方法res.setHeader (&#x27;Access-Control-Allow-Methods&#x27;, &#x27;*&#x27;）\n\n4.5 简单请求同时满足以下两大条件的请求，就属于简单请求：\n\n请求方式： GET 、 POST 、 HEAD 三者之一\nHTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-language、DPR、Downlink、Save-Data、 Viewport-Width、 Width、Content-Type （只有三个值application&#x2F;x-www-form-urlencoded, multipart&#x2F;form-data, text&#x2F;plain)\n\n4.6 预检请求只要符合以下任何一个条件的请求，都需要进行预检请求：\n\n请求方式为 GET 、 POST 、 HEAD 之外的请求 Method 类型\n请求头中包含自定义头部字段\n向服务器发送了 application&#x2F;json 格式的数据在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据\n\n5 jsonp 接口5.1 JSONP 的概念与特点概念：浏览器端通过&lt;script＞标签的 src 属性，请求服务器上的数据，同时服务器返回一个函数的调用。这种请求数据的方式叫做 JSONP特点：\n\nJSONP 不属于真正的 Ajax 请求，因为它没有便用 XMLHttpRequest 这个对象\nJSONP 仅支持 GET 请求，不支持 POST、PUT、DELETE 等请求\n\n5.2 创建 JSONP 接口如果项目中己经配置了 CORS 跨域资源共享，为了防止冲突．必须在配首 CORS 中间件之前声明 ISONP 的接口。否则JSONP 接四会被处理成开启了 CORS 的接口\n// 优先创建 JSONP 接口【这个接口不会被处理成 CORS 接口】app.get(&#x27;/api/jsonp&#x27;, (req, res) =&gt; &#123;&#125;)// 再配置 CORS 中间件【后续的所有接口，都会坡处理成 CORS 接口】const cors = require(&#x27;cors&#x27;)app.use(cors())// 这是一个开启了 CORS 的按口app.get(&#x27;/api/get&#x27;, (req, res) =&gt; &#123;&#125;)\n","categories":["技术"],"tags":["Node"]},{"title":"Node.js 入门 —— 中间件","url":"/2022/12/28/node-middleware/","content":"\n1 前言\n2 中间件的概念\n3 express 中间件\n4 自定义中间件\n\n1 前言本文内容来自bilibili 黑马程序员\n2 中间件的概念2.1 什么是中间件中间件（middleware）特指业务流程的中间处理环节\n2.2 中间件的调用流程当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理\n2.3 Express 中间件的格式本质上是一个 function 处理函数中间件函数的形参列表中，必须包含 next 参数，而路由处理函数只包含 req 和 resnext 函数是实现多个中间件连续调用的关键，它表示将流转关系流转给下一个中间件或者路由\n3 express 中间件3.1 定义中间件函数// 定义一个最简单的中间件函数const mw = (req, res, next) =&gt; &#123;  console.log(&#x27;这是最简单的中间件函数&#x27;);  // 把流转关系，转交给下一个中间件或者路由  next()&#125;\n\n3.2 全局生效的中间件客户端发起的任何请求，到达服务器之后都会触发的中间件，叫做全局生效中间件通过调用 app.use(中间件函数)，即可定义一个全局生效的中间件\napp.use(mw)\n\n3.3 局部生效的中间件不使用 app.use() 定义的中间件，叫做局部生效的中间件\napp.get(&#x27;/user&#x27;, mw, (req, res) =&gt; &#123;&#125;)\n\n3.4 中间件使用注意事项\n除错误级别中间件外，其他类型中间件一定要在路由之前注册\n客户端发送过来的请求，可以连续调用多个中间件进行处理\n执行完中间件的业务代码之后，不要忘记调用 next() 函数\n为了防止代码逻辑混乱，调用 next() 函数后不要再写额外的代码\n连续调用多个中间件时，多个中问件之间，共享 req 和 res 对象\n\n3.5 中间件的分类为了方便大家理解和记忆中间件的使用，Express 官方把常见的中间件用法，分成了5大类，分别是：\n\n应用级别的中间件通过 app.use() 、 app.get() 、 app.post() ，绑定到 app 实例上的中间件// 应用级别的中间件（全局中间件）app.use((req, res, next) =&gt; &#123;  next()&#125;)// 应用级别的中间件（局部中间件）app.get(&#x27;/&#x27;, mw, (req, res) =&gt; &#123;  res.send(&#x27;Hone Npage.&#x27;)&#125;)\n路由级别的中间件绑定到 express.Router() 上的中间件const app = express()const router = express.Router()// 路由级别的中间件router.use(function (req, res, next) &#123;  console.log( &quot;Time:&quot; Date.now())  next()&#125;)app.use(router)\n错误级别的中间件作用：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题格式：错误级别中间件的 function 处理函数中，必须有 4 个形参，形参顺序从前到后，分别是 (err, req, res, next)app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;  throw new Error(&#x27;服务器发生错误&#x27;)  res.send(&#x27;Home Page&#x27;)&#125;)app.use((err, req, res, next) =&gt; &#123;  console.log(&#x27;发生了错误！&#x27;, err.message);  res.send(`发生了错误！$&#123;err.message&#125;`)&#125;)\nExpress 内置的中间件\n\n\nexpress.static() ：快速托管静态资源\nexpress.json() ：解析 JSON 格式的请求数据\nexpress.urlencoded() ：解析 URL-encoded 格式的请求数据\n\n\n第三方的中间件非 express 官方提供的，而是由第三方开发出来的中间件\n\n4 自定义中间件自己手动模拟一个类似于 express.urlencoded 这样的中间件，来解析 POST 提交到服务器的表单数据\n实现步骤：定义中间件监听 req 的 data 事件监听 req 的 end 事件使用 querystring 模块解析请求体数据将解析出来的数据对象挂载为 req.body将自定义中间件封装成模块\n\ncustom-bodyparser.js\nconst qs = require(&#x27;querystring&#x27;) const bodyParser = (req, res, next) =&gt; &#123;  let str = &#x27;&#x27;  req.on(&#x27;data&#x27;, (chunk) =&gt; &#123;    str += chunk  &#125;)  req.on(&#x27;end&#x27;, () =&gt; &#123;    req.body = qs.parse(str)    next()  &#125;)&#125;module.exports = bodyParser\n\nindex.js\nconst express = require(&#x27;express&#x27;)const bodyParser = require(&#x27;./custom-bodyparser&#x27;) const app = express()app.use(bodyParser)app.post(&#x27;/user&#x27;, (req, res) =&gt; &#123;  res.send(req.body)&#125;)app.listen(80, () =&gt; &#123;  console.log(&#x27;http://127.0.0.1&#x27;);&#125;)\n","categories":["技术"],"tags":["Node"]},{"title":"Node.js 入门 —— 初识 Express","url":"/2022/12/28/node-express/","content":"\n1 前言\n2 什么是 express\n3 express 的作用\n4 express 的基本使用\n5 托管静态资源\n6 nodemon\n7 路由的概念\n8 路由的使用\n\n1 前言本文内容来自bilibili 黑马程序员\n2 什么是 express\n官方给出的概念：Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架\n通俗的理解：Express 的作用和 Node.js 内置的http 模块类似，是专门用来创建 Web 服务器的\nExpress 的本质：就是个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法。\n\n3 express 的作用对于前端程序员来说，最常见的两种服务器，分别是：Web 网站服务器：专门对外提供 Web 网页资源的服务器。API 接口服务器：专门对外提供 API接口的服务器。使用 Express，我们可以方便、快速的创建 Web 网站的服务器或 API 接口的服务器。\n4 express 的基本使用4.1 安装在项目所处的日录中，运行如下的终端命令，即可将 express 安装到项目中使用：\nnpm install express\n\n4.2 创建基本的 web 服务器// 1. 导入 expressconst express = require(&#x27;express&#x27;)// 2. 创建 web 服务器const app = express()// 3. 启动 web 服务器app.listen(80, () =&gt; &#123;  console.log(&#x27;express server running at http://127.0.0.1&#x27;);&#125;)\n\n4.3 监听 get 请求通过 app.get() 方法，可以监听客户端的 GET 请求\n// 参数1：客户端请求的 URL 地址// 参数2：请求对应的处理函数//       req：请求对象（包含了与请求相关的属性与方法）//       res：响应对象（包含了与响应相关的属性与方法）app.get(&#x27;请求URL&#x27;，(req, res) =&gt; &#123; /*处理函数*/ &#125;）)\n\n4.4 监听 post 请求通过 app.post() 方法，可以监听客户端的 POST 请求\n// 参数1：客户端请求的 URL 地址// 参数2：请求对应的处理函数//       req：请求对象（包含了与请求相关的属性与方法）//       res：响应对象（包含了与响应相关的属性与方法）app.post(&#x27;请求URL&#x27;，(req, res) =&gt; &#123; /*处理函数*/ &#125;）)\n\n4.5 把内容响应给客户端通过 res.send() 方法，可以把处理好的内容发送给客户端\napp.get(&#x27;/user&#x27;, (req, res) =&gt; &#123;  //向客户端发送 JSON 对象  res.send(&#123; name: &#x27;zs&#x27;, age: 20, gender: &#x27;男&#x27; &#125;)&#125;)app.post(&#x27;/user&#x27;, (req, res) =&gt; &#123;  //向客户端发送文本内容  res.send(&#x27;请求成功&#x27;)&#125;)\n\n4.6 获取 url 中携带的查询参数通过 req.query 对象，可以访问到客户端通过查询字符串的形式，发送到服务器的参数：\napp.get(&#x27;/&#x27;, (req, res) =&gt; &#123;  // 通过 req.query 可以获取到客户端发送过来的查询参数  res.send(req.query)&#125;)\n\n4.7 获取 url 中的动态参数通过 req.params 对象，可以访问到 URL 中，通过：匹配到的动态参数：\napp.get(&#x27;/user:id&#x27;, (req, res) =&gt; &#123;  // 通过 req.params 是动态匹配到的 url 参数，默认是空对象  res.send(req.params)&#125;)\n\n5 托管静态资源5.1 托管单个静态资源express 提供了一个非常好用的函数，叫做 express.static()，通过它，我们可以非常方便地创建一个静态资源服务器例如，通过如下代码就可以将 public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了：\napp.use(express.static(&#x27;public&#x27;))\n\n5.2 托管多个静态资源如果要托管多个静态资源目录，请多次调用 express.static() 函数：访问静态资源文件时，express.static() 函数会根据目录的添加顺序查找所需的文件。\napp.use(express.static(&#x27;public&#x27;))app.use(express.static(&#x27;files&#x27;))\n\n5.3 挂载路径前缀如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式：\napp.use(&#x27;/public&#x27;, express.static(&#x27;public&#x27;))\n\n6 nodemon6.1 为什么要使用 nodemon在编写调试 Node.js 项目的时候，如果修改了项目的代码，则需要频繁的手动 close 掉，然后再重新启动，非常繁琐。现在，我们可以使用 nodemon (https://www.npmjs.com/package/nodemon） 这个工具，它能够监听项目文件的变动，当代码被修改后，nodemon 会自动帮我们重启项目，极大方便了开发和调试。\n6.2 安装 nodemonnpm i -g nodemon\n\n6.3 使用 nodemon# node app.jsnodemon app.js\n\n7 路由的概念7.1 什么是路由路由就是映射关系\n7.2 Express 中的路由在 Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系。Express 中的路由分 3 部分组成，分别是请求的类型、请求的 URL 地址、处理函数，格式如下：\napp.METHOD(PATH, HANDLER)\n\n8 路由的使用为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。将路由抽离为单独模块的步骤如下：\n\n创建路由模块对应的 .js 文件\n调用 express.Router() 函数创建路由对象\n向路由对象上挂载具体的路由\n使用module.exports 向外共享路由对象\n使用app.use() 函数注册路由模块\n\napp.js\nconst express = require(&#x27;express&#x27;)const router = require(&#x27;./router&#x27;)const app = express()// app.use() 函数的作用，就是来注册全局中间件app.use(&#x27;/api&#x27;, router)app.listen(80, () =&gt; &#123;  console.log(&#x27;your server is running at http://127.0.0.1&#x27;);&#125;)\n\nrouter.js\nconst express = require(&#x27;express&#x27;)const router = express.Router()router.get(&#x27;/user/list&#x27;, (req, res) =&gt; res.send(&#x27;get user list&#x27;))router.post(&#x27;/user/add&#x27;, (req, res) =&gt; res.send(&#x27;add new user&#x27;))module.exports = router\n","categories":["技术"],"tags":["Node"]},{"title":"Node.js 入门 —— 模块的加载机制","url":"/2022/12/18/node-loading-mechanism-of-modules/","content":"\n1 前言\n2 模块的加载机制\n\n1 前言本文内容来自bilibili 黑马程序员\n2 模块的加载机制2.1 优先从缓存中加载模块在第一次加载后会被缓存。这也意味看多次调用require()不会导致模块的代码被执行多次。\n注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。\n\n2.2 内置模块的加载机制内置模块是由 Node.js 官方提供的模块，内置模块的加载优先级最高。例如， require(‘fs’) 始终返回内置的 fs 模块，即使在 node_modules 目录下有名字相同的包也叫做 fs。\n2.3 自定义模块的加载机制\n使用 require() 加载自定义模块时，必须指定以 ./ 或 ../ 开头的路径标识符。\n在加载自定义模块时，如果没有指定 ./ 或 ../ 这样的路径标识符，则 Node.js 会把它当作内置模块或第三方模块进行加载。\n同时，在使用 require() 导入自定义模块时，如果省略了文件的扩展名，则 Node.js 会按顺序分别尝试加载以下的文件：\n\n\n按照确切的文件名进行加载\n补全 .js 扩展名进行加载\n补全 .json 扩展名进行加载\n补全 .node 抗展名进行加载\n加载失败终端报错\n\n2.4 第三方模块的加载机制\n如果传递给 require() 的模块标识符不是一个内置模块，也没有以 ./ 或 ../ 开头，则 Node.js 会从当前模块的父目录开始，尝试从 node_modules 文件夹中加载第三方模块。\n如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。例如，假设在“C:\\Users\\itheima\\project\\foo.js’ 文件里调用了 require(‘tools’)，则 Node.js 会按以下顺序查找：\n\n\nC:\\Users\\itheima\\project\\node_modules\\tools\nC:\\Users\\itheima\\node_modules\\tools\nC:\\Users\\node_modules\\tools\nC:\\node_modules\\tools\n\n2.5 目录作为模块当把目录作为模块标识符，传递给 require() 进行加载的时候，有三种加载方式：\n\n在被加载的目录下查找一个叫做 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口\n如果目录里没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。\n如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：Error: Cannot find module ‘xxx’\n\n","categories":["技术"],"tags":["Node"]},{"title":"Node.js 入门 —— npm 与包","url":"/2022/12/18/node-npm/","content":"\n1 前言\n2 包\n3 新增包\n4 发布包\n\n1 前言本文内容来自bilibili 黑马程序员\n2 包2.1 什么是包Node.js 中的第三方模块，又叫做包从 https://www.npmjs.com/ 网站上搜索自己所需要的包从 https://registry.npmjs.org/ 服务器上下载自己需要的包\n2.2 规范的包结构\n必须以单独的目录存在\n顶级目录下必须包含 package.json 这个包管理配置文件\npackage.json 中必须包含 name （包名）、 version （版本号）、 main （入口文件）这三个属性\n\n3 新增包\n新建文件夹 itheima-test\n新建 package.jsonitheima-test 文件夹下新建 package.json&#123;  &quot;name&quot;: &quot;itheima-test&quot;, // 名称自定义  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;type&quot;: &quot;module&quot;,  &quot;description&quot;: &quot;提供了格式化时间等功能&quot;,  &quot;keywords&quot;: [&quot;dateFormat&quot;],  &quot;license&quot;: &quot;ISC&quot;&#125;\n新建 README.mditheima-test 文件下新建 README.md\n\n## 安装npm install itheima-test## 导入方式import format from &#x27;itheima-test&#x27;## 格式化时间const dtStr = format.dateFormat(new Date) // 2022-12-18 16:45:34## 开源协议ISC\n\n新建 index.jsitheima-test 文件夹下新建 index.js\n\n// 这是包的入口文件import format from &quot;./src/dateFormat.js&quot;;export default &#123;  ...format&#125;\n\n新建 dateFormat.jsitheima-test 文件夹下新建 src 文件夹， src 文件夹下新建 dateFormat.js\n\nconst padZero = (n) =&gt; &#123;  return n &lt; 10 ? `0$&#123;n&#125;` : n&#125;// 定义时间格式化方法const dateFormat = (dateStr) =&gt;&#123; const dt = new Date(dateStr) const y = padZero(dt.getFullYear()) const m = padZero(dt.getMonth() + 1) const d = padZero(dt.getDate()) const hh = padZero(dt.getHours()) const mm = padZero(dt.getMinutes()) const ss = padZero(dt.getSeconds()) return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`&#125;export default &#123;  padZero,  dateFormat&#125;\n\n4 发布包若没有 npm 账号，需要先访问 https://registry.npmjs.org/ 注册一个\n// 登录 npmnpm login// 发布包npm publish// 删除包npm unpublish 包名 --force","categories":["技术"],"tags":["Node"]},{"title":"Node.js 入门 —— 模块化","url":"/2022/12/14/node-modularization/","content":"\n1 前言\n2 模块化的基本概念\n3 node 中的模块化\n4 node 中的模块作用域\n5 es6 module\n\n1 前言本文内容来自bilibili 黑马程序员\n2 模块化的基本概念2.1模块化\n模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、可分解、可更换的单位。\n编程领域中的模块化，就是遵循固定规则，把一个大文件拆成独立并相互依赖的多个小模块。\n\n模块化的好处提高代码的复用性提高代码的可维护性可以实现按需加载\n\n2.2 模块化规范模块化规范就是对代码进行模块化拆分、组合时，需要遵循的规则。\n\n使用什么样的语法格式来引用模块\n使用什么样的语法格式来向外暴露成员模块化规范的好处大家都遵循同样的模块化规范写代码，降低了沟通成本，极大方便了各个模块之间的相互调用，利人利己。\n\n3 node 中的模块化3.1 node 中模块化的分类Node.js 根据模块的来源不同，将模块分为三大类，分别是：\n\n内置模块：由 Node.js 官方提供的，如 fs 模块、 path 模块、 http 模块\n自定义模块：用户创建的每一个 .js 文件，都是自定义模块\n外部模块：由第三方开发出来的模块，非 Node.js 官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载\n\n3.2 加载模块使用强大的 require() 方法，可以加载需要的内置模块、自定义模块、外部模块进行使用\n// 加载内置模块const http = require(&#x27;http&#x27;)// 加载自定义模块const custom = require(&#x27;./custom.js&#x27;)// 加载外部模块const moment = require(&#x27;moment&#x27;)\n\n注意：\n\n使用 require() 方法加载其他模块时，会执行被加载模块中的代码\n在使用 require() 加载用户自定义模块期间，可以省略 .js 的后缀名\n\n4 node 中的模块作用域4.1 什么是模块作用域和函数作用域类似，自定义模块中定义的变量、方法等成员，只能在当前模块被访问，这种模块级别的访问限制，叫做模块作用域。\n4.2 模块作用域的好处防止全局变量污染问题\n4.3 向外共享模块作用域中的成员在每个 .js 自定义模块中都有一个 module 对象，它里面存储了和当前模块有关的信息\n4.3.1 module.exports 对象\n在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。\n外界用 require() 方法导入自定义模块时，得到的就是 module exports 所指向的对象\n\n共享成员时的注意：使用 require() 方法导入模块时，导入的结果，永远以 module exports 所指向的对象为准\n\n// m1.jsconst userName = &#x27;zs&#x27;module.exports.userName = userNamemodule.exports.sayHello = () =&gt; console.log(&#x27;hello&#x27;);module.exports = &#123;  userName: &#x27;ls&#x27;,  sayHi: () =&gt; console.log(&#x27;hello&#x27;)&#125;// test.jsconst m1 = require(&#x27;./m1&#x27;)console.log(m1) // &#123; userName: &#x27;ls&#x27;, sayHi: [Function: sayHi] &#125;\n\n// m1.jsconst userName = &#x27;zs&#x27;module.exports = &#123;  userName: &#x27;ls&#x27;,  sayHi: () =&gt; console.log(&#x27;hello&#x27;)&#125;module.exports.userName = userNamemodule.exports.sayHello = () =&gt; console.log(&#x27;hello&#x27;);// test.jsconst m1 = require(&#x27;./m1&#x27;)console.log(m1) // &#123;                //   userName: &#x27;zs&#x27;,                //   sayHi: [Function: sayHi],                //   sayHello: [Function (anonymous)]                // &#125;\n\n4.3.2 exports 对象\n由于 module.exports 单词写起来比较复杂，为了简化向外共享成员的代码， Node.js 提供了 exports 对象。\n默认情况下，exports 和 module exports 指向同一个对象，最终共享的结果，还是以 module.exports 指向的对象为准。\n\n4.3.3 exports 和 module exports 的使用误区时刻谨记， require() 模块时，得到的永远都是 module.exports 指向的对象：\nexports.userName = &#x27;zs&#x27;module.exports = &#123;  userName: &#x27;ls&#x27;,  age: 23&#125;// &#123; userName: &#x27;ls&#x27;, age: 23 &#125;\n\nmodule.exports.userName = &#x27;zs&#x27;exports = &#123;  userName: &#x27;ls&#x27;,  age: 23&#125;// &#123; userName: &#x27;zs&#x27; &#125;\n\nexports.userName = &#x27;zs&#x27;module.exports.age = 23// &#123; userName: &#x27;zs&#x27;, age: 23 &#125;\n\nexports = &#123;  userName: &#x27;zs&#x27;,&#125;module.exports = exportsmodule.exports.age = 23// &#123; userName: &#x27;zs&#x27;, age: 23 &#125;\n\n4.4 node 中的模块化规范Node.js 遵循了 CommonJS 模块化规范， CommonJS 规定了模块的特性和各模块间如何相互依赖。\nCommonJS 规定：每个模块内部， module 变量代表当前模块module 变量是一个对象，它的 export 属性（即 module.exports）是对外的接口加载某个模块，其实是加载该模块 module.exports 属性。 require() 方法用来加载模块\n\n5 es6 moduleES6 在语言标准的层面上，实现了模块功能，旨在替代 AMD 、 CommonJs 成为浏览器和服务器通用的模块解决方案。\nES6 Module 规定：每个 js 文件都是一个独立的模块按需导入： import ，命令用于输入其他模块提供的功能按需导出 ： export ，命令用于规定模块的对外接口\n","categories":["技术"],"tags":["Node"]},{"title":"Node.js 入门 —— http 模块","url":"/2022/12/12/node-http-module/","content":"\n1 前言\n2 什么是 http 模块\n3 http 模块的作用\n4 服务器相关概念\n5 创建最基本的 web 服务器\n\n1 前言本文内容来自bilibili 黑马程序员\n1.1 什么是客户端，什么是服务器在网络节点中，负责消费网络资源的电脑叫客户端；负责对外提供网络资源的电脑叫服务器\n2 什么是 http 模块http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。通过 http 模块提供的 http.createServer() 方法，就能方便地把一台普通电脑，变成一台 web 服务器，从而对外提供 web 资源服务\n3 http 模块的作用\n服务器与普通电脑的区别在于，服务器上安装了很多 web 服务器软件，例如 IIS 、 Apache 等，通过安装这些服务器软件，就能把一台普通电脑变成一台 web 服务器\n在 Node.js 中，我们不需要使用 IIS 、 Apache 等这些第三方 web 服务器软件。因为我们可以基于 Node.js 提供的 http 模块，通过几行简单的代码，就能轻松地手写一个服务器软件，从而对外提供 web 服务\n\n4 服务器相关概念4.1 IP 地址\nIP 地址就是互联网上每台计算机的唯一地址，因此 IP 地址具有唯一性。如果把“个人电脑”比作“一台电话”，那么“IP 地址”就相当于“电话号码”，只有知道对方 IP 地址的前提下，才能与对应的电脑之间进行数据通信。\nIP 地址的格式：通常使用“点分十进制”表示成（a.b.c.d）的形式，其中 a.b.c.d 都是 0~255 之间的十进制整数，例如用点分十进制表示的 IP 地址（192.168.1.1）\n\n注意：互联网中每台 web 服务器，都有自己的 IP 地址，例如大家可以在终端上运行 ping www.baidu.com 命令，即可查看到百度服务器的 IP 地址在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入 127.0.0.1 这个 IP 地址，就能把自己的电脑当做一台服务器进行访问了。\n\n4.2 域名和域名服务器\n尽管 IP 地址能够唯一地标记网络上的计算机，但 IP 地址是一长串数字，不够直观，且不便于记忆，于是人们又发明了另一套字符型的地址方案，即所谓的域名（Domain Name）地址\nIP 地址和域名是一一对应的关系，这份对应关系存放在一种叫做域名服务器（DNS, Domain Name Server）的电脑中，使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器来实现。因此，域名服务器就是提供 IP 地址和域名之间的转换服务的服务器\n\n注意：单纯使用 IP 地址，互联网中的电脑也能正常工作，但有了域名的加持，能让互联网的世界变得更加便捷在开发测试期间，127.0.0.1 对应的域名是 localhost ，它们都代表我们的这台电脑，在使用效果上没有任何区别\n\n4.3 端口号\n计算机中的端口号，就好像是现实生活中的门牌号一样，通过门牌号，外卖小哥可以在整栋大楼众多房间中，准确地将外卖送到你的手中。\n同样的道理，在一台电脑中可以运行成百上千个 web 服务器，每个 web 服务器都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号可以准确地交给对应的 web 服务进行处理\n\n注意：每个端口号不能同时被多个 web 服务占用在实际应用中， URL 中的 80 端口可以省略\n\n5 创建最基本的 web 服务器5.1 基本步骤\n导入 http 模块\n创建 web 服务器实例\n为服务器绑定 request 事件，监听客户端的请求\n启动服务器\n\n// 1.导入 http 模块const http = require(&quot;http&quot;);// 2.创建 web 服务器实例const server = http.createServer();// 3.为服务器实例绑定 request 时间server.on(&quot;request&quot;, (req, res) =&gt; &#123;  // 只要有客户端来请求服务器，就会触发 request 事件，从而调用这个事件处理函数  console.log(&quot;someone visits our web server&quot;);&#125;);// 4.启动服务器server.listen(8080, () =&gt; &#123;  console.log(&quot;http server running at http://127.0.0.1:8080&quot;);&#125;);\n\n5.2 req 请求对象只要服务器接收到了客户端的请求，就会调用通过 server.on 为服务器绑定的 request 事件处理函数如果想在事件处理函数中，访问与客户端相关的数据或属性，可以使用如下方法：\n// req 是请求对象，包含了与客户端相关的数据和属性server.on(&quot;request&quot;, (req, res) =&gt; &#123;  // 只要有客户端来请求服务器，就会触发 request 事件，从而调用这个事件处理函数  // req.url ：客户端请求的 url 地址  const url = req.url;  // req.method ：客户端请求的 method 类型  const method = req.method;  console.log(    `Your request url is $&#123;url&#125;, and the request method is $&#123;method&#125;`  );&#125;);\n\n5.3 res 响应对象在服务器的 request 事件处理函数中，如果想访问与服务端器相关的数据或属性，可以使用如下方法：\n// res 是响应对象，包含了与服务器相关的数据和属性server.on(&quot;request&quot;, (req, res) =&gt; &#123;  const str = `Your request url is $&#123;req.url&#125;, and the request method is $&#123;req.method&#125;`;  // 像客户端发送指定内容，并结束这次请求的处理过程  res.end(str);&#125;);\n\n5.4 解决中文乱码问题手动设置返回内容的编码格式\n// res 是响应对象，包含了与服务器相关的数据和属性server.on(&quot;request&quot;, (req, res) =&gt; &#123;  const str = `您请求的 url 是 $&#123;req.url&#125;, 请求的 method 类型是 $&#123;req.method&#125;`;  res.setHeader(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;);  res.end(str);&#125;);\n\n5.5 根据不同的 url 返回不同的内容实现步骤\n\n获取请求的 url 地址\n设置默认的响应内容为 404 Not Found\n判断用户请求是否为 &#x2F; 或 &#x2F;index.html 首页\n判断用户请求是否为 &#x2F;about.html 关于页面\n设置 Content-Type 响应头，避免中文乱码问题\n使用 res.end() 把内容响应给客户端\n\nconst http = require(&quot;http&quot;);const server = http.createServer();server.on(&quot;request&quot;, (req, res) =&gt; &#123;  const url = req.url;  let contnet = &quot;&lt;h1&gt;404 Not Found&lt;/h1&gt;&quot;;  if (url === &quot;/&quot; || url === &quot;/index.html&quot;) &#123;    contnet = &quot;&lt;h1&gt;首页&lt;/h1&gt;&quot;;  &#125; else if (url === &quot;/about.html&quot;) &#123;    contnet = &quot;&lt;h1&gt;关于页面&lt;/h1&gt;&quot;;  &#125;  res.setHeader(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;);  res.end(contnet);&#125;);server.listen(&quot;80&quot;);\n\n5.6 返回本地文件实现步骤\n\n导入需要的 node 模块\n创建基本的 web 服务器\n将资源的请求 url 地址映射为文件的存放路径\n读取文件内容并响应给客户端\n优化资源的请求路径\n\n// 1. 导入需要的 node 模块const fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);const http = require(&quot;http&quot;);// 2. 创建基本的 web 服务器const server = http.createServer();server.on(&quot;request&quot;, (req, res) =&gt; &#123;  // 3. 将资源的请求 url 地址映射为文件的存放路径  // 4. 读取文件内容并响应给客户端  // 5. 优化资源的请求路径  const url = req.url;  fs.readFile(    path.join(      __dirname,      &quot;../path路径模块/files/&quot;,      url === &quot;/&quot; ? &quot;index.html&quot; : url    ),    &quot;utf-8&quot;,    (err, dataStr) =&gt; &#123;      if (err) return res.end(&quot;404 Not Found&quot;);      res.end(dataStr);    &#125;  );&#125;);server.listen(&quot;80&quot;, () =&gt; &#123;  console.log(&quot;server running at http://127.0.0.1&quot;);&#125;);\n","categories":["技术"],"tags":["Node"]},{"title":"Node.js 入门 —— path 路径模块","url":"/2022/12/09/node-path-module/","content":"\n1 前言\n2 什么是 path 模块\n3 path 相关方法\n4 综合\n\n1 前言本文内容来自bilibili 黑马程序员\n2 什么是 path 模块path 模块是 Node.js 官方提供的用来处理路径的模块，它提供了一系列的方法和属性，用来满足用户对路径的处理需求\n3 path 相关方法3.1 path.join()用来将多个路径片段拼接成一个完整的路径字符串\n// path.join([...paths])const path = require(&#x27;path&#x27;)const fs = require(&#x27;fs&#x27;)// 注意， &#x27;../&#x27; 会抵消上一层路径// const pathStr = path.join(&#x27;/a&#x27;, &#x27;/b/c&#x27;, &#x27;../&#x27;, &#x27;d&#x27;, &#x27;e&#x27;)// console.log(pathStr); // &#x27;/a/b/d/e&#x27;const pathStr = path.join(&#x27;/a&#x27;, &#x27;/b/c&#x27;, &#x27;../../&#x27;, &#x27;d&#x27;, &#x27;e&#x27;)console.log(pathStr); // &#x27;/a/d/e&#x27;// fs.readFile(__dirname + &#x27;/files/1.txt&#x27;)// fs.readFile(__dirname + &#x27;./files/1.txt&#x27;) // 报错，会将 . 拼接到路径上fs.readFile(path.join(__dirname, &#x27;./files/1.txt&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123;  if (err) &#123;    console.log(&#x27;读取文件失败&#x27;, err);    return  &#125;  console.log(data);&#125;)\n\n3.2 path.basename()用来从路径字符串中，将文件名解析出来\n// path.basename(path[, ext])const path = require(&#x27;path&#x27;)// 定义文件的存放路径const fpath = &#x27;/a/b/c/index.html&#x27;// const basename = path.basename(fpath)// console.log(basename); // &#x27;index.htmlconst basename = path.basename(fpath, &#x27;.html&#x27;)console.log(basename); // &#x27;index&#x27;\n\n3.3 path.extname()用来从路径字符串中，将后缀名解析出来\n// path.extname(path)const path = require(&#x27;path&#x27;)// 定义文件的存放路径const fpath = &#x27;/a/b/c/index.html&#x27;const extname = path.extname(fpath)console.log(extname); // &#x27;.html\n\n4 综合将以下 HTML 文件拆分成 index.html 、 index.css 、 index.js 三个文件，并将三个文件，并将文件存放到 files 文件夹下\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;style&gt;    body&#123;      background-color: red;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;h3&gt;welcome to my channel&lt;/h3&gt;  &lt;script&gt;    setTimeout(() =&gt; &#123;      console.log(&#x27;welcome to my channel&#x27;);    &#125;, 3000);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n4.1 实现步骤\n创建两个正则表达式，分别用来匹配 &lt;style&gt; 和 &lt;script&gt; 标签\n使用 fs 模块，读取需要被处理的 HTML 文件\n自定义 resolveCss 方法，来写入 index.css 文件\n自定义 resolveJs 方法，来写入 index.js 文件\n自定义 resolveHtml 方法，来写入 index.html 文件\n\n4.2 完整代码// 1.1 导入 fs 模块const fs = require(&#x27;fs&#x27;)// 1.2 导入 path 模块const path = require(&#x27;path&#x27;)// 1.3 匹配 &lt;style&gt;&lt;/style&gt; 标签的正则// /s：匹配空白字符 /S：匹配非空白字符 *：匹配任意次const regStyle = /&lt;style&gt;[\\s\\S]*&lt;\\/style&gt;/// 1.4 匹配 &lt;script&gt;&lt;/script&gt; 标签的正则const regScript = /&lt;script&gt;[\\s\\S]*&lt;\\/script&gt;/// 2.1 调用 fs.readFile() 方法读取文件fs.readFile(path.join(__dirname, &#x27;./index.html&#x27;), &#x27;utf-8&#x27;, (err, dataStr) =&gt; &#123;  // 2.2 读取 HTML 文件失败  if (err) return console.log(&#x27;读取文件失败&#x27;, err);  // 2.3 读取 HTML 文件成功，调用对应的三个方法  resolveCss(dataStr)  resolveJs(dataStr)  resolveHtml(dataStr)&#125;)// 3.1 处理 css 样式const resolveCss = (htmlStr) =&gt; &#123;  // 3.2 使用正则提取页面中的 &lt;style&gt;&lt;/style&gt; 标签  const r1 = regStyle.exec(htmlStr)  // 3.3 将提取出来的 css 字符串做进一步的处理  const newCss = r1[0].replace(&#x27;&lt;style&gt;&#x27;, &#x27;&#x27;).replace(&#x27;&lt;/style&gt;&#x27;, &#x27;&#x27;)  // 3.4 将处理好的 css 字符串写入 index.css 文件中   fs.writeFile(path.join(__dirname, &#x27;./files/index.css&#x27;), newCss, err =&gt; &#123;    if (err) return console.log(&#x27;写入文件失败&#x27;, err);    console.log(&#x27;写入文件成功&#x27;);  &#125;)&#125;// 4.1 处理 jsconst resolveJs = (htmlStr) =&gt; &#123;  // 3.2 使用正则提取页面中的 &lt;script&gt;&lt;/script&gt; 标签  const r1 = regScript.exec(htmlStr)  // 3.3 将提取出来的 js 字符串做进一步的处理  const newJs = r1[0].replace(&#x27;&lt;script&gt;&#x27;, &#x27;&#x27;).replace(&#x27;&lt;/script&gt;&#x27;, &#x27;&#x27;)  // 3.4 将处理好的 js 字符串写入 index.js 文件中   fs.writeFile(path.join(__dirname, &#x27;./files/index.js&#x27;), newJs, err =&gt; &#123;    if (err) return console.log(&#x27;写入文件失败&#x27;, err);    console.log(&#x27;写入文件成功&#x27;);  &#125;)&#125;// 5.1 处理 htmlconst resolveHtml = (htmlStr) =&gt; &#123;  // 5.2 将内嵌的 style 和 script 标签替换成内联的 link 和 script 标签  const newHtml = htmlStr.replace(regStyle, &#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot; /&gt;&#x27;).replace(regScript, &#x27;&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&#x27;)  // 5.3 写入 index.html 文件  fs.writeFile(path.join(&#x27;./files/index.html&#x27;), newHtml, err =&gt; &#123;    if (err) return console.log(&#x27;写入文件失败&#x27;, err);    console.log(&#x27;写入文件成功&#x27;);  &#125;)&#125;\n\n4.3 注意事项\nfs.writeFile() 只能用来创建文件，不能用来创建路径\n重复调用 fs.writeFile() 写入同一个文件，新写入的内容会覆盖之前的旧内容\n\n","categories":["技术"],"tags":["Node"]},{"title":"Vue3 模板引用 —— 获取 ref 实例","url":"/2022/11/29/vue3-ref/","content":"\n1 简单模板引用\n2 数组模板引用\n3 函数模板引用\n\n1 简单模板引用\n为了通过组合式 API 获得该模板引用，需要声明一个同名的 ref\n\n&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;// 声明一个 ref 来存放该元素的引用// 必须和模板里的 ref 同名const inputRef = ref(null)onMounted(() =&gt; &#123;  // 获取 ref  inputRef.value.focus()&#125;)&lt;/script&gt;&lt;template&gt;  &lt;input ref=&quot;inputRef&quot; /&gt;&lt;/template&gt;\n\n2 数组模板引用\nref 数组并不保证与源数组相同的顺序\n\n&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;const list = ref([  /* ... */])// 存放 refconst itemRefs = ref([])onMounted(() =&gt; &#123;  // 获取 ref  console.log(itemRefs.value)&#125;)&lt;/script&gt;&lt;template&gt;  &lt;ul&gt;    &lt;li v-for=&quot;item in list&quot; :key=&quot;item&quot; ref=&quot;itemRefs&quot;&gt;      &#123;&#123; item &#125;&#125;    &lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;\n\n3 函数模板引用&lt;template&gt;  &lt;el-tabs v-model=&quot;activeName&quot; type=&quot;card&quot;&gt;    &lt;div v-for=&quot;tab in tabList&quot; :key=&quot;tab.name&quot;&gt;      &lt;el-tab-pane :label=&quot;tab.lable&quot; :name=&quot;tab.name&quot;&gt;        &lt;List v-bind=&quot;tab.props&quot; :ref=&quot;(el: Element) =&gt; setTabRef(el, tab.name)&quot; /&gt;      &lt;/el-tab-pane&gt;    &lt;/div&gt;  &lt;/el-tabs&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;const activeName = ref(&#x27;all&#x27;)const tabList = [  &#123;    lable: &#x27;全部&#x27;,    name: &#x27;all&#x27;  &#125;,  &#123;    lable: &#x27;进行中&#x27;,    name: &#x27;doing&#x27;  &#125;,  &#123;    lable: &#x27;已完成&#x27;,    name: &#x27;finished&#x27;  &#125;]// 存放 refconst tabRef = &#123;&#125;const setTabRef = (el: Element, tabName: string) =&gt; &#123;  if (el) tabRef[tabName] = el&#125;const loadListData = (tabName: string) =&gt; &#123;  // 获取 ref  tabRef[tabName].getListData()&#125;&lt;/script&gt;","categories":["技术"],"tags":["Vue3"]},{"title":"Vue3 动态路由","url":"/2022/11/25/vue3-dynamic-routing/","content":"\n1 修改 router.ts 文件\n2 添加 activeRoutes.ts 文件\n3 修改登录 Vue 文件\n4 修改退出登录 Vue 文件\n\n1 修改 router.ts 文件import &#123; addActiveRoutes &#125; from &#x27;./activeRoutes&#x27;let init = truerouter.beforeEach((to, from, next) =&gt; &#123;  // 刷新时重新加载动态路由  if (init) &#123;    init = false    addActiveRoutes()    next(to)    return  &#125;&#125;)export default router\n\n2 添加 activeRoutes.ts 文件import type &#123; RouteRecordRaw &#125; from &#x27;vue-router&#x27;const errorRoute = &#123;  path: &#x27;/:pathMatch(.*)&#x27;,  name: &#x27;Error&#x27;,  component: () =&gt; import(&#x27;@/views/Error.vue&#x27;),&#125;const activeRoutes: RouteRecordRaw[] = [  &#123;    path: &#x27;/A&#x27;,    name: &#x27;A&#x27;,    component: () =&gt; import(&#x27;@/A.vue&#x27;)  &#125;,  &#123;    path: &#x27;/B&#x27;,    name: &#x27;B&#x27;,    component: () =&gt; import(&#x27;@/B.vue&#x27;)  &#125;]export const addActiveRoutes = () =&gt; &#123;  if (***) &#123; // 添加判断条件    activeRoutes.forEach((route) =&gt; &#123;      if (router.hasRoute(route.name)) return // 避免重复添加      router.addRoute(route)      // router.addRoute(&#x27;Parent&#x27;, route) // 若是某个路由的子路由，第一个参数为该路由name    &#125;)  &#125;  // 错误路由必须在动态路由后添加，否则会被匹配上  router.addRoute(errorRoute)&#125;export const removeActiveRoutes = () =&gt; &#123;  activeRoutes.forEach((route) =&gt; &#123;    if (router.hasRoute(route.name)) &#123;      router.removeRoute(route.name)    &#125;  &#125;)  router.removeRoute(&#x27;Error&#x27;)&#125;\n\n3 修改登录 Vue 文件import &#123; addActiveRoutes &#125; from &#x27;@/router/activeRoutes&#x27;// 登录成功后调用addActiveRoutes()\n\n4 修改退出登录 Vue 文件import &#123; removeActiveRoutes &#125; from &#x27;@/router/activeRoutes&#x27;// 退出登录成功后调用removeActiveRoutes()","categories":["技术"],"tags":["Vue3","Vue Router4"]},{"title":"Vue3 + Element Plus 实现大文件切片上传及进度条展示","url":"/2022/11/18/vue3-chunk-upload/","content":"\n1 前言\n2 功能实现\n3 完整代码\n4 拓展\n\n1 前言最近在做一个项目的重构，其中有大文件上传的功能，由于项目是几年前，代码没有前后分离，用的是 jQuery + webuploader 库做的，但实际上只是实现了大文件切片上传，并没有切片并发、秒传及断点续传功能，后端也不支持，且 webuploader 库已经不再维护了，故决定自己实现一个最简单的大文件切片上传功能。\n2 功能实现2.1 添加 Element Plus 上传代码及进度条展示代码&lt;template&gt;  &lt;el-upload    accept=&quot;.mp3, .m4a, .aac, .mp4, .m4v&quot;    :before-upload=&quot;beforeUpload&quot;    :http-request=&quot;upload&quot;    :show-file-list=&quot;false&quot;    :disabled=&quot;disabled&quot;    style=&quot;display: inline-block&quot;  &gt;    &lt;el-tooltip placement=&quot;bottom&quot;&gt;      &lt;template #content&gt;        可上传本地录音录像，支持上传的        &lt;br /&gt;音频格式为：mp3、m4a、aac        &lt;br /&gt;        视频格式为：mp4、m4v      &lt;/template&gt;      &lt;el-button type=&quot;primary&quot; :disabled=&quot;disabled&quot;&gt;        上传录音录像      &lt;/el-button&gt;    &lt;/el-tooltip&gt;  &lt;/el-upload&gt;  &lt;el-dialog    v-model=&quot;dialogVisible&quot;    :fullscreen=&quot;true&quot;    :show-close=&quot;false&quot;    custom-class=&quot;dispute-upload-dialog&quot;  &gt;    &lt;div class=&quot;center&quot;&gt;      &lt;div class=&quot;fz-18 ellipsis&quot;&gt;正在上传：&#123;&#123; fileData.name &#125;&#125;&lt;/div&gt;      &lt;el-progress :text-inside=&quot;true&quot; :stroke-width=&quot;16&quot; :percentage=&quot;percentage&quot; /&gt;      &lt;el-button @click=&quot;cancel&quot;&gt;取消上传&lt;/el-button&gt;    &lt;/div&gt;  &lt;/el-dialog&gt;&lt;/template&gt;\n\n2.2 限制文件上传类型和大小const beforeUpload = (file: File) =&gt; &#123;  const mimeTypes = [&#x27;audio/mpeg&#x27;, &#x27;audio/x-m4a&#x27;, &#x27;audio/aac&#x27;, &#x27;video/mp4&#x27;, &#x27;video/x-m4v&#x27;]  if (!mimeTypes.includes(file.type)) &#123;    ElMessage(&#123;      type: &#x27;error&#x27;,      message: &#x27;只能上传 MP3、M4A、AAC、MP4、M4V 格式的文件&#x27;,      duration: 6000    &#125;)    return false  &#125;  if (file.size / 1024 / 1024 / 1024 &gt; 1.5) &#123;    ElMessage.error(&#x27;文件大小不能超过 1.5G&#x27;)    ElMessage(&#123;      type: &#x27;error&#x27;,      message: &#x27;文件大小不能超过 1.5G&#x27;,      duration: 6000    &#125;)    return false  &#125;  return true&#125;\n\n2.3 判断文件大小，小文件直接上传const chunkSize = 1 * 1024 * 1024 // 切片大小const upload = async (file: &#123; file: File &#125;) =&gt; &#123;  const fileObj = file.file  const nameList = fileObj.name.split(&#x27;.&#x27;)  fileData.value.name = fileObj.name  fileData.value.size = fileObj.size  fileData.value.type = fileObj.type  fileData.value.suffix = nameList[nameList.length - 1]  if (chunkSize &gt; fileData.value.size) &#123; // 文件大小小于切片大小，直接上传    disabled.value = true    axios      .post(&#x27;upload&#x27;, fileObj) // 调用后端上传文件接口      .then((res) =&gt; &#123;        ElMessageBox(&#123; message: `$&#123;fileData.value.name&#125;上传成功`, title: &#x27;提示&#x27; &#125;)        updateUrl(res.data) // 调用后端保存上传文件路径接口      &#125;)      .catch(() =&gt; ElMessageBox(&#123; message: `$&#123;fileData.value.name&#125;上传失败`, title: &#x27;提示&#x27; &#125;)) // 上传失败弹框      .finally(() =&gt; (disabled.value = false))    return  &#125;  batchUpload(fileObj) // 大文件切片上传&#125;\n\n2.4 大文件获取文件唯一标识// 重构项目没有断点续传等功能，故不需要做hash计算，只需要保证唯一即可，后端会拿这个值新建文件夹保存切片let counter = 0const getFileMd5 = () =&gt; &#123;  let guid = (+new Date()).toString(32)  for (let i = 0; i &lt; 5; i++) &#123;    guid += Math.floor(Math.random() * 65535).toString(32)  &#125;  return &#x27;wu_&#x27; + guid + (counter++).toString(32)&#125;\n2.5 计算切片数量const percentage = ref(0)const dialogVisible = ref(false)const cancelUpload = ref(false)const batchUpload = async (fileObj: File) =&gt; &#123;  percentage.value = 0 // 每次上传文件前清空进度条  dialogVisible.value = true // 显示上传进度  cancelUpload.value = false // 每次上传文件前将取消上传标识置为 false  const chunkCount = Math.ceil(fileData.value.size / chunkSize) // 切片数量  fileData.value.md5 = getFileMd5() // 文件唯一标识  for (let i = 0; i &lt; chunkCount; i++) &#123;    if (cancelUpload.value) return // 若已经取消上传，则不再上传切片    const res = await uploadChunkFile(i, fileObj) // 上传切片    if (res.code !== 0) &#123; // 切片上传失败      dialogVisible.value = false      ElMessageBox(&#123; message: `$&#123;fileData.value.name&#125;上传失败`, title: &#x27;提示&#x27; &#125;)      return    &#125;    if (i === chunkCount - 1) &#123; // 最后一片切片上传成功      setTimeout(() =&gt; &#123; // 延迟关闭上传进度框用户体验会更好        dialogVisible.value = false        ElMessageBox(&#123; message: `$&#123;fileData.value.name&#125;上传成功`, title: &#x27;提示&#x27; &#125;)        axios.post(&#x27;mergeUpload&#x27;, &#123; folder: fileData.value.md5 &#125;) // 调用后端合并切片接口，参数需要与后端对齐          .then((res) =&gt; updateUrl(res.data)) // 调用后端保存上传文件路径接口      &#125;, 500)    &#125;  &#125;&#125;\n\n2.6 上传切片let controller: AbortController | null = null // 当前切片上传 AbortControllerconst uploadChunkFile = async (i: number, fileObj: File) =&gt; &#123;  const start = i * chunkSize // 切片开始位置  const end = Math.min(fileData.value.size, start + chunkSize) // 切片结束位置  const chunkFile = fileObj.slice(start, end) // 切片文件  const formData = new FormData() // formData 参数需要与后端对齐  formData.append(&#x27;fileName&#x27;, fileData.value.name)  formData.append(&#x27;folder&#x27;, fileData.value.md5)  formData.append(&#x27;file&#x27;, chunkFile, String(i + 1)) // 必传字段；若第三个参数不传，切片 filename 默认是 blob ，如果后端是以切片名称来做合并的，则第三个参数一定要传  controller = new AbortController() // 每一次上传切片都要新生成一个 AbortController ，否则重新上传会失败  return await axios    .post(&#x27;mergeUpload&#x27;, formData, &#123; // 调用后端上传切片接口      onUploadProgress: (data) =&gt; &#123; // 进度条展示        percentage.value = Number(          (            (Math.min(fileData.value.size, start + data.loaded) / fileData.value.size) *            100          ).toFixed(2)        )      &#125;,      signal: controller.signal // 取消上传    &#125;)    .then((res) =&gt; updateUrl(res.data))&#125;\n\n2.7 取消上传const cancel = () =&gt; &#123;  dialogVisible.value = false  cancelUpload.value = true  controller?.abort()  axios.post(&#x27;cancelUpload&#x27;, &#123; folder: fileData.value.md5 &#125;) // 调用后端接口，删除已上传的切片&#125;\n\n3 完整代码&lt;template&gt;  &lt;el-upload    accept=&quot;.mp3, .m4a, .aac, .mp4, .m4v&quot;    :before-upload=&quot;beforeUpload&quot;    :http-request=&quot;upload&quot;    :show-file-list=&quot;false&quot;    :disabled=&quot;disabled&quot;    style=&quot;display: inline-block&quot;    class=&quot;m-x-12&quot;  &gt;    &lt;el-tooltip placement=&quot;bottom&quot;&gt;      &lt;template #content&gt;        可上传本地录音录像，支持上传的        &lt;br /&gt;音频格式为：mp3、m4a、aac        &lt;br /&gt;        视频格式为：mp4、m4v      &lt;/template&gt;      &lt;el-button type=&quot;primary&quot; style=&quot;font-size: 12px&quot; :disabled=&quot;disabled&quot;&gt;        上传录音录像      &lt;/el-button&gt;    &lt;/el-tooltip&gt;  &lt;/el-upload&gt;  &lt;el-dialog    v-model=&quot;dialogVisible&quot;    :fullscreen=&quot;true&quot;    :show-close=&quot;false&quot;    custom-class=&quot;dispute-upload-dialog&quot;  &gt;    &lt;div class=&quot;center&quot;&gt;      &lt;div class=&quot;fz-18 ellipsis&quot;&gt;正在上传：&#123;&#123; fileData.name &#125;&#125;&lt;/div&gt;      &lt;el-progress :text-inside=&quot;true&quot; :stroke-width=&quot;16&quot; :percentage=&quot;percentage&quot; /&gt;      &lt;el-button @click=&quot;cancel&quot;&gt;取消上传&lt;/el-button&gt;    &lt;/div&gt;  &lt;/el-dialog&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import axios from &#x27;axios&#x27;const beforeUpload = (file: File) =&gt; &#123;  const mimeTypes = [&#x27;audio/mpeg&#x27;, &#x27;audio/x-m4a&#x27;, &#x27;audio/aac&#x27;, &#x27;video/mp4&#x27;, &#x27;video/x-m4v&#x27;]  if (!mimeTypes.includes(file.type)) &#123;    ElMessage(&#123;      type: &#x27;error&#x27;,      message: &#x27;只能上传 MP3、M4A、AAC、MP4、M4V 格式的文件&#x27;,      duration: 6000    &#125;)    return false  &#125;  if (file.size / 1024 / 1024 / 1024 &gt; 1.5) &#123;    ElMessage.error(&#x27;文件大小不能超过 1.5G&#x27;)    ElMessage(&#123;      type: &#x27;error&#x27;,      message: &#x27;文件大小不能超过 1.5G&#x27;,      duration: 6000    &#125;)    return false  &#125;  return true&#125;const dialogVisible = ref(false)const cancelUpload = ref(false)let controller: AbortController | null = nullconst chunkSize = 1 * 1024 * 1024 // 切片大小const percentage = ref(0)const fileData = ref(&#123;  name: &#x27;&#x27;,  size: 0,  type: &#x27;&#x27;,  suffix: &#x27;&#x27;,  md5: &#x27;&#x27;&#125;)const cancel = () =&gt; &#123;  dialogVisible.value = false  cancelUpload.value = true  controller?.abort()  axios.post(&#x27;cancelUpload&#x27;, &#123; folder: fileData.value.md5 &#125;)&#125;let counter = 0const getFileMd5 = () =&gt; &#123;  let guid = (+new Date()).toString(32)  for (let i = 0; i &lt; 5; i++) &#123;    guid += Math.floor(Math.random() * 65535).toString(32)  &#125;  return &#x27;wu_&#x27; + guid + (counter++).toString(32)&#125;const updateUrl = (fileUrl: string) =&gt; &#123;  axios.post(&#x27;saveUrl&#x27;, &#123;    fileName: fileData.value.name,    fileUrl  &#125;)&#125;const uploadChunkFile = async (i: number, fileObj: File) =&gt; &#123;  const start = i * chunkSize  const end = Math.min(fileData.value.size, start + chunkSize)  const chunkFile = fileObj.slice(start, end)  const formData = new FormData()  formData.append(&#x27;encrypt&#x27;, &#x27;true&#x27;)  formData.append(&#x27;fileName&#x27;, fileData.value.name)  formData.append(&#x27;folder&#x27;, fileData.value.md5)  formData.append(&#x27;file&#x27;, chunkFile, String(i + 1))  controller = new AbortController()  return await axios    .post(&#x27;mergeUpload&#x27;, formData, &#123;      onUploadProgress: (data) =&gt; &#123;        percentage.value = Number(          (            (Math.min(fileData.value.size, start + data.loaded) / fileData.value.size) *            100          ).toFixed(2)        )      &#125;,      signal: controller.signal    &#125;)    .then((res) =&gt; updateUrl(res.data))&#125;const batchUpload = async (fileObj: File) =&gt; &#123;  percentage.value = 0  dialogVisible.value = true  cancelUpload.value = false  const chunkCount = Math.ceil(fileData.value.size / chunkSize) // 切片数量  fileData.value.md5 = getFileMd5() // 文件唯一标识  for (let i = 0; i &lt; chunkCount; i++) &#123;    if (cancelUpload.value) return    const res = await uploadChunkFile(i, fileObj)    if (res.code !== 0) &#123;      dialogVisible.value = false      ElMessageBox(&#123; message: `$&#123;fileData.value.name&#125;上传失败`, title: &#x27;提示&#x27; &#125;)      return    &#125;    if (i === chunkCount - 1) &#123;      setTimeout(() =&gt; &#123;        dialogVisible.value = false        ElMessageBox(&#123; message: `$&#123;fileData.value.name&#125;上传成功`, title: &#x27;提示&#x27; &#125;)        axios.post(&#x27;mergeUpload&#x27;, &#123; folder: fileData.value.md5 &#125;).then((res) =&gt; updateUrl(res.data))      &#125;, 500)    &#125;  &#125;&#125;const disabled = ref(false)const upload = async (file: &#123; file: File &#125;) =&gt; &#123;  const fileObj = file.file  const nameList = fileObj.name.split(&#x27;.&#x27;)  fileData.value.name = fileObj.name  fileData.value.size = fileObj.size  fileData.value.type = fileObj.type  fileData.value.suffix = nameList[nameList.length - 1]  if (chunkSize &gt; fileData.value.size) &#123;    disabled.value = true    axios      .post(&#x27;upload&#x27;, fileObj)      .then((res) =&gt; &#123;        ElMessageBox(&#123; message: `$&#123;fileData.value.name&#125;上传成功`, title: &#x27;提示&#x27; &#125;)        updateUrl(res.data)      &#125;)      .catch(() =&gt; ElMessageBox(&#123; message: `$&#123;fileData.value.name&#125;上传失败`, title: &#x27;提示&#x27; &#125;))      .finally(() =&gt; (disabled.value = false))    return  &#125;  batchUpload(fileObj)&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;.dispute-upload-dialog &#123;  background: none;&#125;&lt;/style&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.center &#123;  color: #fff;  width: 50%;  text-align: center;  position: absolute;  top: 50%;  left: 50%;  transform: translate(-50%, -50%);&#125;&lt;/style&gt;\n\n4 拓展\nhash 值作为文件唯一标识引入 js-spark-md5 库做文件 hash 计算\n切片并发上传需要控制好并发数量\n秒传上传文件前请求后端接口，通过文件 hash 值判断否存已经上传过该文件，存在则无需再上传该文件，直接返回上传成功，实现秒传\n断点续传上传切片前请求后端接口，通过切片 hash 值判断是否已经上传过该切片，存在则无需再上传该切片，从下一个切片开始上传，实现断点续传\n\n","categories":["技术"],"tags":["Element Plus","Vue3"]},{"title":"Vue3 + PDF.js 实现 PDF 预览","url":"/2022/11/03/vue3-pdfJs/","content":"\n1 前言\n2 PDF 预览测试\n3 修改配置项\n4 移除部分按钮\n5 错误处理\n\n1 前言PDF.js 官网\n\n本文使用的 PDF.js 版本为：v3.0.279\n本文未使用 npm 形式在项目中引入 PDF.js 依赖，因为该形式引入的 PDF.js 需要自己写额外页面样式及按钮，而直接在官网下载可以使用 PDF.js 默认提供的 viewer ，不用再增加额外代码，即可实现 PDF 预览等功能# 使用 npm 形式在项目中引入 PDF.js 依赖npm i pdfjs-dist\n效果预览\n\n2 PDF 预览测试2.1 下载 PDF.js在 PDF.js 官网下载 PDF.js ，解压后放到 public&#x2F;static 下\n2.2 window.open 直接打开// 默认打开 public/static/pdf/web/compressed.tracemonkey-pldi-09.pdf// 测试 pdf 有点大，第一次打开可能会有点慢，只要有进度条就是正常加载中window.open(&#x27;static/pdf/web/viewer.html&#x27;)// 传入 pdf 文件地址const fileUrl = &#x27;xxx&#x27;window.open(&#x27;static/pdf/web/viewer.html?file=&#x27; + fileUrl)\n\n2.3 弹框形式打开&lt;el-dialog v-model=&quot;dialogVisible&quot;&gt;  &lt;iframe :src=&quot;&#x27;static/pdf/web/viewer.html?file=&#x27; + fileUrl&quot;    style=&quot;width: 100%; height: 440px&quot;  &gt;&lt;/iframe&gt;&lt;/el-dialog&gt;\n\n3 修改配置项3.1 修改主题色为暗色系修改 public&#x2F;static&#x2F;pdf&#x2F;web&#x2F;viewer.js\nAUTOMATIC: 0, // 跟随浏览器LIGHT: 1, // 亮色DARK: 2 // 暗色\n\n3.2 修改默认语言为简体中文修改 public&#x2F;static&#x2F;pdf&#x2F;web&#x2F;viewer.js\n3.3 打开 PDF 后默认跳转到某一页// 添加 #page=2 默认跳转到第二页window.open(&#x27;static/pdf/web/viewer.html?file=&#x27; + fileUrl + &#x27;#page=2&#x27;)\n\n4 移除部分按钮4.1 简单按钮移除例：移除[打印]按钮\n4.2 复杂按钮移除例：移除[文本]按钮，由于该按钮点击后会出现面板，所以除了移除当前按钮相关代码外，还要移除面板相关代码\n5 错误处理5.1 跨域报错注释 public&#x2F;static&#x2F;pdf&#x2F;web&#x2F;viewer.js 代码\n5.2 默认语言为简体中文，但下载按钮仍显示为“Save”修改 public&#x2F;static&#x2F;pdf&#x2F;web&#x2F;viewer.html 第159、276行代码如果需要使用到以下两种语言，也需要将 save_label 改为 download_label\n","categories":["技术"],"tags":["Vue3"]},{"title":"Node.js 入门 —— fs 文件系统模块","url":"/2022/10/28/node-file-system-module/","content":"\n1 前言\n2 Node.js 简介\n3 什么是终端\n4 fs 文件系统模块\n\n1 前言本文内容来自bilibili 黑马程序员 \n1.1 为什么 JavaScript 可以在浏览器中被执行？\n浏览器中有 JS 解析引擎Chrome： V8Firefox：OdinMonkey（奥丁猴）Safari：JSCoreIE：Charka（查克拉）\n\n\n1.2 为什么 JavaScript 可以操作 DOM 和 BOM\n每个浏览器都内置了 DOM 和 BOM 这样的 API 函数，因此，浏览器中的 JavaScript 才可以调用它们\n\n\n1.3 浏览器中的 JavaScript 运行环境\n运行环境指的是代码正常运行所需的必要环境V8 引擎负责解析和执行 JavaScript 代码内置的 API 是由运行环境提供的特殊接口，只能在所属的运行环境中被调用\n\n\n1.4 JavaScript 是否能做后端\n可以，Node.js 提供运行环境\n\n2 Node.js 简介2.1 什么是 Node.jsNode 官网\n\nNode.js 是一个基于 Chrome V8 引擎的 JavaScript运行环境\n\n2.2 Node.js 中的 JavaScript 运行环境\n浏览器是 JavaScript 的前端运行环境Node.js 是 JavaScript 的后端运行环境Node.js 中无法调用 DOM、BOM 等浏览器内置 API\n\n\n2.3 Node.js 学习路径\n浏览器中的 JavaScript 学习路径：JavaScript 基础语法 ＋ 浏览器内置 API (DOM + BOM)＋第三方库 (jQuery、art-template 等）\n\n\nNode.js 的学习路径：JavaScript 基础语法 + Nodejs 内置 API 模块（fs、path、http 等）＋ 第三方 API 模块(express. mysal 等）\n\n3 什么是终端\n终端（terminal）是专门为开发人员设计的，用于实现人机交互的一种方式\n\n\n常用终端命令：tab：快速补全文件路径esc：清空当前命令（Ctrl + u）cls：清空当前终端（mac：clear）\n\n4 fs 文件系统模块4.1 什么是 fs 文件系统模块\nfs 模块是 Node.js 官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。例如：• fs.readFile() 方法，用来读取指定文件中的内容• fs.writeFile() 方法，用来向指定的文件中写入内容\n\n如果要在 JavaScript 代码中，使用 fs 模块来操作文件，则需要使用如下的方式先导入它：\nconst fs = require(&quot;fs&quot;);\n\n4.2 fs.readFile()\nfs.readFile(path[, options], callback)参数1：文件的存放路径参数2：读取文件时采用的编码格式，可选，默认 utf8参数3：回调函数，拿到读取成功和失败的结果\n\n/// 1 导入 fs 模块const fs = require(&quot;fs&quot;);// 2 调用 fs.readFile() 读取文件fs.readFile(&quot;./files/1.txt&quot;, &quot;utf8&quot;, (err, dataStr) =&gt; &#123;  // 如果读取成功， err 值为 null  // 如果读取失败， err 值为错误对象， dataStr 值为 undefined  if (err) &#123;    return console.log(&quot;读取文件失败&quot;, err);  &#125;  console.log(&quot;读取文件成功&quot;, dataStr);&#125;);\n\n4.3 fs.writeFile\nfs.writeFile(path, data[, options], callback)参数1：文件的存放路径参数2：要写入的内容参数3：写文件时采用的编码格式，默认 utf8参数4：回调函数，拿到写文件结果\n\n// 1 导入 fs 模块const fs = require(&quot;fs&quot;);// 2 调用 fs.writeFile() 写入文件fs.writeFile(&quot;./files/1.txt&quot;, &quot;写入文件&quot;, (err) =&gt; &#123;  // 如果写入成功，err 值为 null  // 如果写入失败，err 值为 错误对象  if (err) &#123;    return console.log(&quot;写入文件失败&quot;, err);  &#125;  console.log(&quot;写入文件成功&quot;, dataStr);&#125;);\n\n4.4 练习整理前：\n小红=99 小白=100 小黄=70 小黑=66 小绿=88\n整理后：\n小红:99小白:100小黄:70小黑:66小绿:88\n\n\n① 导入需要的fs 文件系統模块② 使用 fs.readFile() 方法，读取素材目录下的 成绩 txt 文件③ 判断文件是否读取失败④ 文件读取成功后，处理成绩数据⑤ 将处理完成的成绩数据，调用 ts.writeFile() 方法，写入到新文件 成绩-before.txt 中\n\nconst fs = require(&quot;fs&quot;);fs.readFile(&quot;./files/成绩.txt&quot;, &quot;utf8&quot;, (err, dataStr) =&gt; &#123;  if (err) &#123;    return console.log(&quot;读取文件失败&quot;);  &#125;  const oldData = dataStr.replaceAll(&quot;=&quot;, &quot;:&quot;).replaceAll(&quot; &quot;, &quot;\\n&quot;);  fs.writeFile(&quot;./files/成绩-after.txt&quot;, oldData, (err) =&gt; &#123;    if (err) &#123;      return console.log(&quot;写入文件失败&quot;);    &#125;    console.log(&quot;写入文件成功&quot;);  &#125;);&#125;);\n\n4.5 路径动态拼接问题在使用 fs 模块操作文件时，如果提供的操作路径是以 .&#x2F;或 ..&#x2F;开头的相对路径时，很容易出现路径动态拼接错误的问题。\n\n原因：代码在运行的时候，会以执行 node 命令时所处的目录，动态拼接出被操作文件的完整路径解决方案：在使用 fs 模块操作文件时，直接提供完整的路径，不要提供 .&#x2F; 或 ..&#x2F;开头的相对路径，从而防止路径动态拼接的问题\n\n// __dirname 表示当前执行脚本所在的目录const fs = require(&quot;fs&quot;);fs.readFile(__dirname + &quot;/files/成绩.txt&quot;, &quot;utf8&quot;);","categories":["技术"],"tags":["Node"]},{"title":"Vue3 + Pinia 持久化存储","url":"/2022/10/09/vue3-pinia-plugin-persist/","content":"\n1 前言\n2 持久化存储\n3 高级配置\n\n1 前言\n本文使用 Pinia 及插件 pinia-plugin-persist 做持久化存储，避免修改 store 后还需要手动修改 storage\n本文弃用插件 pinia-plugin-persistedstate，该插件无法配置一个 store 中的变量分别存储于 localStorage 和 sessionStorage\n\n2 持久化存储2.1 安装依赖pnpm i pinia // 安装 piniapnpm i pinia-plugin-persist // 安装持久化存储插件\n\n2.2 新增 store 文件\n新增 store 文件夹\nstore 文件夹下新增 index.ts 文件import type &#123; App &#125; from &#x27;vue&#x27;import &#123; createPinia &#125; from &#x27;pinia&#x27;import piniaPluginPersist from &#x27;pinia-plugin-persist&#x27;const store = createPinia()store.use(piniaPluginPersist)export function setupStore(app: App&lt;Element&gt;) &#123;  app.use(store)&#125;export &#123; store &#125;\n\n2.3 修改 main.ts 文件import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#123; setupStore &#125; from &#x27;./store&#x27;import router from &#x27;./router/routes&#x27;const app = createApp(App)setupStore(app)app.use(router).mount(&#x27;#app&#x27;)\n\n2.4 持久化存储测试\nstore 文件夹下新增 modules 文件夹\nmodules 文件夹下新增 user.ts 文件import &#123; defineStore &#125; from &#x27;pinia&#x27;const userStore = defineStore(&#x27;user&#x27;, &#123;  state: () =&gt; &#123;    return &#123;      accessToken: &#x27;&#x27;,      userName: &#x27;&#x27;    &#125;  &#125;,  actions: &#123;    SET_ACCESS_TOKEN(token: string) &#123;      this.accessToken = token    &#125;,    SET_USER_NAME(name: string) &#123;      this.userName = name    &#125;  &#125;,  persist: &#123;    enabled: true,  &#125;&#125;)export default userStore\n\n若不生效，需检查全局是否注册多个 Pinia （全局搜索createPinia）\n\n比如 main.ts 文件重新注册了 Pinia\nimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#123; createPinia &#125; from &#x27;pinia&#x27;import router from &#x27;./router/routes&#x27;const pinia = createPinia()const app = createApp(App)app.use(pinia)app.use(router).mount(&#x27;#app&#x27;)\n\n3 高级配置3.1 存储所有变量默认存储到 sessionStorage ，key 为 store 的 id\npersist: &#123;  enabled: true&#125;\n存储到 localStorage ，key 为 store 的 id\npersist: &#123;  enabled: true,  strategies: [    &#123;      storage: localStorage,    &#125;,  ]&#125;\n自定义存储 key 值\npersist: &#123;  enabled: true,  strategies: [    &#123;      key: &#x27;piniaStore&#x27;,      storage: localStorage,    &#125;,  ]&#125;\n3.2 存储部分变量默认存储到 sessionStorage\npersist: &#123;  enabled: true,  strategies: [    &#123;      paths: [&#x27;accessToken&#x27;]    &#125;,  ]&#125;\n自定义存储到 localStorage\npersist: &#123;  enabled: true,  strategies: [    &#123;      storage: localStorage,      paths: [&#x27;accessToken&#x27;]    &#125;,  ]&#125;\n自定义存储到 sessionStorage 和 localStorage\npersist: &#123;  enabled: true,  strategies: [    &#123; storage: sessionStorage, paths: [&#x27;userName&#x27;] &#125;,    &#123; storage: localStorage, paths: [&#x27;accessToken&#x27;] &#125;  ]&#125;\n\n","categories":["技术"],"tags":["Vue3","Pinia"]},{"title":"Vue3组合式函数 —— Vue hooks","url":"/2022/09/30/vue3-hooks/","content":"\n1 前言\n2 技术细节\n3 示例\n\n1 前言\n前言摘抄自 Vue.js 官网组合式函数介绍\n\n1.1 什么是“组合式函数”在 Vue 应用的概念中，“组合式函数”(Composables) 是一个利用 Vue 的组合式 API 来封装和复用有状态逻辑的函数。\n1.2 和 Mixin 的对比“组合式函数”和 Vue 2 中的 mixins 功能比较相近，它也让我们能够把组件逻辑提取到可复用的单元里。然而 mixins 有三个主要的短板：\n\n\n不清晰的数据来源：当使用了多个 mixin 时，实例上的数据属性来自哪个 mixin 变得不清晰，这使追溯实现和理解组件行为变得困难。这也是我们推荐在组合式函数中使用 ref + 解构模式的理由：让属性的来源在消费组件时一目了然。\n命名空间冲突：多个来自不同作者的 mixin 可能会注册相同的属性名，造成命名冲突。若使用组合式函数，你可以通过在解构变量时对变量进行重命名来避免相同的键名。\n隐式的跨 mixin 交流：多个 mixin 需要依赖共享的属性名来进行相互作用，这使得它们隐性地耦合在一起。而一个组合式函数的返回值可以作为另一个组合式函数的参数被传入，像普通函数那样。\n\n2 技术细节\n命名规范：组合式函数约定用驼峰命名法命名，并以“use”作为开头\n复用有状态逻辑：变量使用 ref 包裹并抛出\n生命周期钩子：可使用 vue 组件生命周期钩子函数，会先进入组合式函数生命周期，再进入组件内部生命周期\n\n3 示例\n新增 useCustomTab.ts 文件\nimport &#123; ref, onActivated &#125; from &#x27;vue&#x27;export default function () &#123;  const loading = ref(true)  const getData = (isLoading: boolean) =&gt; &#123;    // isLoading：组件传入参数    loading.value = isLoading    setTimeout(() =&gt; &#123;      // 模拟异步接口请求完成后取消 loading      loading.value = false    &#125;, 3000);  &#125;  onActivated(() =&gt; &#123;    getData(true) // 先调用  &#125;)  return &#123;    loading,    getData  &#125;&#125;\n\n在组件中使用\n&lt;template&gt;  &lt;div v-loading=&quot;loading&quot;&gt;    xxx  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import useCustomTab from &#x27;@/hooks/useCustomTab&#x27;const &#123; loading, getData &#125; = useCustomTab()onActivated(() =&gt; &#123;  getData(true) // 后调用&#125;)&lt;/script&gt;\n\n","categories":["技术"],"tags":["Vue3"]},{"title":"qiankun + Vite 实现最简微前端","url":"/2022/09/19/qiankun/","content":"\n1 前言\n2 主应用接入 qiankun\n3 微应用接入 qiankun\n4 应用间通信\n\n1 前言\n前言摘抄自 qiankun 官网微前端介绍\n\n1.1 微前端定义微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(Frontend Monolith)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。\n1.2 微前端架构核心价值\n技术栈无关主框架不限制接入应用的技术栈，微应用具备完全自主权\n独立开发、独立部署微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新\n增量升级在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略\n独立运行时每个微应用之间状态隔离，运行时状态不共享\n\n2 主应用接入 qiankun2.1 安装 qiankunnpm i qiankun\n\n2.2 基于路由配置方式接入\nmain.ts\nimport &#123; registerMicroApps, start &#125; from &#x27;qiankun&#x27;import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;const app = createApp(App)app.use(router)app.mount(&#x27;#app&#x27;)// 注册微应用registerMicroApps(  [    &#123;      name: &#x27;subApp&#x27;, // 必须与微应用注册名字相同      entry: &#x27;http://localhost:8000&#x27;, // 入口路径，开发时为微应用所启本地服务，上线时为微应用线上路径      container: &#x27;#sub-app-container&#x27;, // app.vue 配置的挂载容器 id      activeRule: &#x27;/home&#x27;, // 当访问路由为 home 时加载微应用      props: &#123;        // 主应用向微应用传递参数      &#125;    &#125;  ],  &#123;    // 生命周期钩子函数    // beforeLoad: (app) =&gt; &#123;    //   console.log(&#x27;beforeLoad&#x27;, app)    // &#125;,    // beforeMount: (app) =&gt; &#123;    //   console.log(&#x27;beforeMount &#x27;, app)    // &#125;,    // afterMount: (app) =&gt; &#123;    //   console.log(&#x27;afterMount&#x27;, app)    // &#125;    // beforeUnmount: (app) =&gt; &#123;    //   console.log(&#x27;beforeUnmount &#x27;, app)    // &#125;,    // afterUnmount: (app) =&gt; &#123;    //   console.log(&#x27;afterUnmount&#x27;, app)    // &#125;  &#125;)// 启动 qiankunstart()\n\napp.vue\n&lt;template&gt;  &lt;!-- 提供挂载容器 --&gt;  &lt;div id=&quot;sub-app-container&quot;&gt;&lt;/div&gt;&lt;/template&gt;\n\n2.3 手动加载微应用方式接入\nsubApp.vue&lt;template&gt;  &lt;button @click=&quot;loadApp&quot;&gt;挂载微应用&lt;/button&gt;  &lt;button @click=&quot;unloadApp&quot;&gt;卸载微应用&lt;/button&gt;  &lt;!-- 提供挂载容器 --&gt;  &lt;div id=&quot;sub-app-container&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;import &#123; loadMicroApp &#125; from &#x27;qiankun&#x27;let microApp: any = null // 微应用实例const loadApp = () =&gt; &#123;  if (microApp) return  microApp = loadMicroApp(&#123;    name: &#x27;subApp&#x27;, // 必须与微应用注册名字相同    entry: &#x27;http://localhost:8000&#x27;, // 入口路径，开发时为微应用所启本地服务，上线时为微应用线上路径    container: &#x27;#sub-app-container&#x27;,    props: &#123;      // 主应用向微应用传递参数    &#125;  &#125;)  microApp.mountPromise.then(() =&gt; &#123;    // 微应用加载完成后回调  &#125;)&#125;const unloadApp = () =&gt; &#123;  if (!microApp) return  microApp.unmount() // 卸载微应用&#125;&lt;/script&gt;\n\n3 微应用接入 qiankun3.1 安装 vite-plugin-qiankun\nqiankun 暂不支持 Vite 方式接入，需安装 vite-plugin-qiankun\n\nnpm i vite-plugin-qiankun\n\n3.2 接入 qiankun\nvite.config.ts\nimport &#123; defineConfig &#125; from &#x27;vite&#x27;import qiankun from &#x27;vite-plugin-qiankun&#x27;export default defineConfig((mode) =&gt; &#123;  return &#123;    plugins: [      qiankun(&#x27;subApp&#x27;, &#123; // 微应用名字，与主应用注册的微应用名字保持一致        useDevMode: true,      &#125;),    ],  &#125;&#125;)\n\nmain.ts\nimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#123;  renderWithQiankun,  qiankunWindow,  QiankunProps,&#125; from &#x27;vite-plugin-qiankun/dist/helper&#x27;const render = (props: QiankunProps = &#123;&#125;) =&gt; &#123;  const &#123; container &#125; = props  const app: string | Element = container?.querySelector(&#x27;#subApp&#x27;) || &#x27;#subApp&#x27; // 避免 id 重复导致微应用挂载失败  createApp(App).mount(app)&#125;const initQianKun = () =&gt; &#123;  renderWithQiankun(&#123;    bootstrap() &#123;      console.log(&#x27;微应用：bootstrap&#x27;)    &#125;,    mount(props) &#123; // 获取主应用传入数据      console.log(&#x27;微应用：mount&#x27;, props)      render(props)    &#125;,    unmount(props) &#123;      console.log(&#x27;微应用：unmount&#x27;, props)    &#125;,    update(props) &#123;      console.log(&#x27;微应用：update&#x27;, props)    &#125;,  &#125;)&#125;qiankunWindow.__POWERED_BY_QIANKUN__ ? initQianKun() : render() // 判断是否使用 qiankun ，保证项目可以独立运行\n\n4 应用间通信4.1 全局挂载\nprops 直接传递// 主应用在注册微应用时通过props传参&#123;  name: &#x27;subApp&#x27;, // 必须与微应用注册名字相同  entry: &#x27;http://localhost:8000&#x27;, // 入口路径，开发时为微应用所启本地服务，上线时为微应用线上路径  container: &#x27;#sub-app-container&#x27;, // 挂载容器 id  props: &#123;    // 主应用向微应用传递参数    msg: &#x27;主应用参数&#x27;  &#125;&#125;\nwindow 全局挂载const testFun = () =&gt; &#123;&#125;window[subApp] = &#123; testFun &#125;\n\n4.2 initGlobalState\n该 API 虽然还在官方文档中展示，但 qiankun 源代码中已不推荐使用，但未提供新的通信方案\n\n\n\n主应用新增 actions.ts 文件\nimport &#123; initGlobalState, MicroAppStateActions &#125; from &#x27;qiankun&#x27;const state = &#123;  msg: &#x27;主应用消息&#x27;&#125;// 初始化 stateconst actions: MicroAppStateActions = initGlobalState(state)export default actions\n\nsubApp.vue\n&lt;template&gt;  &lt;button @click=&quot;clickButton&quot;&gt;主应用按钮&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import actions from &#x27;@/actions&#x27;actions.onGlobalStateChange((state, prevState) =&gt; &#123;  console.log(state, prevState)&#125;)const clickButton = () =&gt; &#123;  actions.setGlobalState(&#123;    msg: &#x27;主应用修改主应用消息&#x27;  &#125;)&#125;&lt;/script&gt;\n\n子应用main.ts\nconst initQianKun = () =&gt; &#123;  renderWithQiankun(&#123;    bootstrap() &#123;      console.log(&#x27;微应用：bootstrap&#x27;)    &#125;,    mount(props) &#123; // 获取主应用传入数据      console.log(&#x27;微应用：mount&#x27;, props)      props.actions.setGlobalState(&#123; msg: &#x27;微应用修改主应用消息&#x27; &#125;)      render(props)    &#125;,    unmount(props) &#123;      console.log(&#x27;微应用：unmount&#x27;, props)    &#125;,    update(props) &#123;      console.log(&#x27;微应用：update&#x27;, props)    &#125;,  &#125;)&#125;\n\n","categories":["技术"],"tags":["qiankun","微前端"]},{"title":"Vue3 + Element Plus 多级嵌套菜单动态渲染","url":"/2022/08/30/element-plus-menu/","content":"\n1 前言\n2 sub-menu 组件\n3 menu 组件\n\n1 前言1.1 功能\n动态渲染多级嵌套菜单\n点击菜单跳转页面\n子菜单高亮，对应父级菜单也高亮\n不同路由高亮同一菜单\n\n1.2源码\n地址： https://gitee.com/YanaDH/vue3-element-template/tree/master\n路径： src&#x2F;layout&#x2F;components&#x2F;sidebar&#x2F;menu\n\n2 sub-menu 组件&lt;template&gt;  &lt;el-sub-menu :index=&quot;menu.name&quot; v-if=&quot;menu.childMenu&quot;&gt;    &lt;template #title&gt;      &lt;el-icon&gt;&lt;Menu /&gt;&lt;/el-icon&gt;      &lt;span&gt;&#123;&#123; menu.chineseName &#125;&#125;&lt;/span&gt;    &lt;/template&gt;    &lt;!-- 多级嵌套菜单渲染 --&gt;    &lt;sub-menu :menu=&quot;menuItem&quot; v-for=&quot;menuItem in menu.childMenu&quot; :key=&quot;menuItem.name&quot;&gt;&lt;/sub-menu&gt;  &lt;/el-sub-menu&gt;  &lt;el-menu-item :index=&quot;menu.name&quot; v-else&gt;    &lt;el-icon&gt;&lt;Menu /&gt;&lt;/el-icon&gt;    &lt;template #title&gt;&#123;&#123; menu.chineseName &#125;&#125;&lt;/template&gt;  &lt;/el-menu-item&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;interface Menu &#123;  name: string //菜单唯一标识，与路由名保持一致  chineseName: string //菜单显示名称  childMenu?: Menu[] | undefined //子菜单&#125;defineProps&lt;&#123;  menu: Menu&#125;&gt;()&lt;/script&gt;\n\n3 menu 组件&lt;template&gt;  &lt;el-menu :default-active=&quot;defaultActive&quot; router&gt;    &lt;sub-menu :menu=&quot;menu&quot; v-for=&quot;menu in menuList&quot; :key=&quot;menu.name&quot;&gt;&lt;/sub-menu&gt;  &lt;/el-menu&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; computed &#125; from &#x27;vue&#x27;import &#123; useRoute &#125; from &#x27;vue-router&#x27;import SubMenu from &#x27;./subMenu.vue&#x27;// useRoute().meta?.parentMenu ： 自定义路由点亮菜单，在路由的 meta 上配置 parentMenu 字段，值为父级菜单的 name 值const defaultActive = computed(() =&gt; useRoute().meta?.parentMenu || useRoute().name)const menuList = [  &#123;    name: &#x27;home&#x27;,    chineseName: &#x27;首页&#x27;  &#125;,  &#123;    name: &#x27;literature&#x27;,    chineseName: &#x27;文学&#x27;,    childMenu: [      &#123;        name: &#x27;cartoon&#x27;,        chineseName: &#x27;动漫&#x27;,      &#125;,      &#123;        name: &#x27;essay&#x27;,        chineseName: &#x27;散文随笔&#x27;,        childMenu: [          &#123;            name: &#x27;youth_literature&#x27;,            chineseName: &#x27;青春文学&#x27;,          &#125;        ]      &#125;,      &#123;        name: &#x27;suspenseful_reasoning&#x27;,        chineseName: &#x27;悬疑推理&#x27;,        childMenu: [          &#123;            name: &#x27;history&#x27;,            chineseName: &#x27;历史&#x27;,          &#125;,          &#123;            name: &#x27;noval&#x27;,            chineseName: &#x27;小说&#x27;,            childMenu: [              &#123;                name: &#x27;fiction&#x27;,                chineseName: &#x27;科幻&#x27;,              &#125;,              &#123;                name: &#x27;martial_arts&#x27;,                chineseName: &#x27;武侠&#x27;,              &#125;            ]          &#125;        ]      &#125;    ]  &#125;,  &#123;    name: &#x27;psychology&#x27;,    chineseName: &#x27;心理学&#x27;,  &#125;]&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;// 子菜单高亮，对应父级菜单也高亮.el-menu ::v-deep(.el-sub-menu.is-active &gt; .el-sub-menu__title) &#123;  color: var(--el-color-primary);&#125;&lt;/style&gt;\n","categories":["技术"],"tags":["Element Plus","Vue3"]},{"title":"Vue3 + Element Plus 实现动态标签页及右键菜单","url":"/2022/08/11/element-plus-dropdown/","content":"\n1 前言\n2 生成动态标签页\n3 生成右键菜单\n\n1 前言1.1 目的Tabs 动态标签页实现右键菜单【关闭当前标签页】、【关闭左侧标签页】、【关闭右侧标签页】、【关闭其他标签页】、【关闭全部标签页】功能\n1.2 普通右键菜单网上使用比较多的是v-contextmenu插件实现右键菜单，但该插件对于v-for循环生成的元素失效，插件内部右键菜单显示执行的是emit(&#39;show&#39;)未传入当前元素节点（可能后续会修复），且样式需要自行修改\n1.3 本文右键菜单方式本文使用element-plus自带的el-dropdown实现右键菜单\n2 生成动态标签页2.1 准备变量容器&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;interface TabType &#123;  title: string //标签页显示名称  componentName: string //动态组件名  data: any //动态组件传参&#125;interface TabListType extends TabType &#123;  name: string //标签页唯一标识，添加标签页时根据 componentName 自动生成&#125;const tabList = ref&lt;TabListType[]&gt;([]) //存放标签页数组const tabValue = ref(&#x27;home&#x27;) //存放当前激活标签页，默认激活首页&lt;/script&gt;\n\n2.2 构造标签页\n可动态添加标签页\n除【首页】外，可动态移除标签页&lt;template&gt;  &lt;el-tabs v-model=&quot;tabValue&quot; type=&quot;card&quot; @tab-remove=&quot;removeTab&quot;&gt;    &lt;el-tab-pane label=&quot;首页&quot; name=&quot;home&quot;&gt;      &lt;Home /&gt;    &lt;/el-tab-pane&gt;    &lt;el-tab-pane v-for=&quot;item in tabList&quot; :name=&quot;item.name&quot; :key=&quot;item.name&quot; closable&gt;      &lt;component :is=&quot;item.componentName&quot; v-bind=&quot;item.data&quot;&gt;      &lt;/component&gt;    &lt;/el-tab-pane&gt;  &lt;/el-tabs&gt;&lt;/template&gt;\n\n2.3 动态添加标签页const addTab = (tab: TabType) =&gt; &#123;   //保证相同组件路径标签页 name 标识唯一  const name = `$&#123;tab.componentName&#125;_$&#123;Date.now()&#125;`  tabList.value.push(&#123;    ...tab,    name  &#125;)  tabValue.value = name&#125;addTab(&#123;  title: &#x27;标签1&#x27;,  componentName: &#x27;tag1&#x27;,  data: &#123;    test: &#x27;这是测试数据&#x27;  &#125;&#125;)\n\n2.4 动态移除标签页const removeTab = (targetName: string) =&gt; &#123;  const index = tabList.value.findIndex((item) =&gt; item.name === targetName)  tabList.value.splice(index, 1)  //当前激活标签页与触发右键菜单标签页是同一页  if (targetName === tabValue.value) &#123;    //当前激活标签页是标签页数组的第一个，则将激活标签页设置为 home    //当前激活标签页不是标签页数组的第一个，则将激活标签页设置为当前激活标签页的前一页    tabValue.value = index === 0 ? &#x27;home&#x27; : tabList.value[index - 1].name  &#125;&#125;removeTab(&#x27;tag1&#x27;)\n\n3 生成右键菜单3.1 扩展标签页&lt;template&gt;  &lt;el-tabs v-model=&quot;tabValue&quot; type=&quot;card&quot; @tab-remove=&quot;removeTab&quot;&gt;    &lt;el-tab-pane label=&quot;首页&quot; name=&quot;home&quot;&gt;      &lt;Home /&gt;    &lt;/el-tab-pane&gt;    &lt;el-tab-pane v-for=&quot;item in tabList&quot; :name=&quot;item.name&quot; :key=&quot;item.name&quot; closable&gt;      &lt;!-- 右键菜单开始：自定义标签页显示名称，保证每个标签页都能实现右键菜单 --&gt;      &lt;template #label&gt;        &lt;el-dropdown          trigger=&quot;contextmenu&quot;          :id=&quot;item.name&quot;          @visible-change=&quot;handleChange($event, item.name)&quot;          ref=&quot;dropdownRef&quot;        &gt;          &lt;span :class=&quot;tabValue === item.name ? &#x27;label&#x27; : &#x27;&#x27;&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/span&gt;          &lt;template #dropdown&gt;            &lt;el-dropdown-menu&gt;              &lt;el-dropdown-item @click=&quot;removeTab(item.name)&quot;&gt;                &lt;el-icon&gt;&lt;Close /&gt;&lt;/el-icon&gt;关闭当前标签页              &lt;/el-dropdown-item&gt;              &lt;el-dropdown-item                @click=&quot;removeTab(item.name, &#x27;left&#x27;)&quot;                v-if=&quot;show(item.name, &#x27;left&#x27;)&quot;              &gt;                &lt;el-icon&gt;&lt;DArrowLeft /&gt;&lt;/el-icon&gt;关闭左侧标签页              &lt;/el-dropdown-item&gt;              &lt;el-dropdown-item                @click=&quot;removeTab(item.name, &#x27;right&#x27;)&quot;                v-if=&quot;show(item.name, &#x27;right&#x27;)&quot;              &gt;                &lt;el-icon&gt;&lt;DArrowRight /&gt;&lt;/el-icon&gt;关闭右侧标签页              &lt;/el-dropdown-item&gt;              &lt;el-dropdown-item                @click=&quot;removeTab(item.name, &#x27;other&#x27;)&quot;                v-if=&quot;tabList.length &gt; 1&quot;              &gt;                &lt;el-icon&gt;&lt;Operation /&gt;&lt;/el-icon&gt;关闭其他标签页              &lt;/el-dropdown-item&gt;              &lt;el-dropdown-item @click=&quot;removeTab(item.name, &#x27;all&#x27;)&quot;&gt;                &lt;el-icon&gt;&lt;Minus /&gt;&lt;/el-icon&gt;关闭全部标签页              &lt;/el-dropdown-item&gt;            &lt;/el-dropdown-menu&gt;          &lt;/template&gt;        &lt;/el-dropdown&gt;      &lt;/template&gt;      &lt;!-- 右键菜单结束 --&gt;      &lt;component :is=&quot;item.componentName&quot; v-bind=&quot;item.data&quot;&gt;      &lt;/component&gt;    &lt;/el-tab-pane&gt;  &lt;/el-tabs&gt;&lt;/template&gt;\n\n3.2 增加 show 方法\n触发右键菜单标签页为第一个时，不展示【关闭左侧标签页】\n触发右键菜单标签页为最后一个时，不展示【关闭右侧标签页】const show = (name: string, type: string) =&gt; &#123;  const index = tabList.value.findIndex((item) =&gt; name === item.name)  return type === &#x27;left&#x27; ? index !== 0 : index !== tabList.value.length - 1&#125;\n\n3.3 扩展 removeTab 方法const removeTab = (targetName: string, type?: string) =&gt; &#123;  const index = tabList.value.findIndex((item) =&gt; item.name === targetName) //查找触发右键菜单所在标签页index  const currentIndex = tabList.value.findIndex((item) =&gt; item.name === tabValue.value) //查找当前激活标签页index，存在当前激活标签页与触发右键菜单标签页不是同一个的情况  switch (type) &#123;    case &#x27;all&#x27;: //关闭全部标签页      tabList.value = [] //清空除【首页】外所有标签页      tabValue.value = &#x27;home&#x27; //修改标签激活页      break    case &#x27;other&#x27;: //关闭其他标签页      tabList.value = [tabList.value[index]]      if (targetName !== tabValue.value) &#123;        tabValue.value = targetName      &#125;      break    case &#x27;left&#x27;: //关闭左侧标签页      tabList.value.splice(0, index)      if (currentIndex &lt; index) &#123;        tabValue.value = targetName      &#125;      break    case &#x27;right&#x27;: //关闭右侧标签页      tabList.value.splice(index + 1)      if (currentIndex &gt; index) &#123;        tabValue.value = targetName      &#125;      break    default: //默认关闭当前标签页      tabList.value.splice(index, 1)      //当前激活标签页与触发右键菜单标签页是同一页      if (targetName === tabValue.value) &#123;        //当前激活标签页是标签页数组的第一个，则将激活标签页设置为 home        //当前激活标签页不是标签页数组的第一个，则将激活标签页设置为当前激活标签页的前一页        tabValue.value = index === 0 ? &#x27;home&#x27; : tabList.value[index - 1].name      &#125;      break  &#125;&#125;\n\n3.4 解决重复出现菜单问题\n当连续在多个标签页触发右键时，会出现多个菜单，解决方案为：在触发右键菜单后，关闭其他右键菜单const dropdownRef = ref()const handleChange = (visible: boolean, name: string) =&gt; &#123;  if (!visible) return  dropdownRef.value.forEach((item: &#123; id: string; handleClose: () =&gt; void &#125;) =&gt; &#123;    if (item.id === name) return    item.handleClose()  &#125;)&#125;\n\n3.5 解决自定义标签样式问题&lt;style lang=&quot;scss&quot; scoped&gt;.label &#123;  color: var(--el-color-primary); //激活标签页高亮&#125;:deep(.el-tabs__item) &#123;  &amp;:hover &#123;    span &#123;      color: var(--el-color-primary); //鼠标移到标签页高亮    &#125;  &#125;  .el-dropdown &#123;    line-height: inherit; // 统一标签页显示名称行高  &#125;&#125;&lt;/style&gt;\n","categories":["技术"],"tags":["Element Plus","Vue3"]},{"title":"setTimeout 与 setInterval —— 实现优雅轮询","url":"/2022/07/29/setTimeout/","content":"\n1 定义与用法\n2 setInterval缺陷\n3 优雅轮询\n\n1 定义与用法1.1 setTimeout1.1.1 定义在指定的毫秒数后调用函数或计算表达式\n1.1.2 用法setTimeout(code/function, milliseconds, param1, param2, ...)\n\n1.1.3 技术细节\ncode&#x2F;function\t ：必需，要调用一个代码串，也可以是一个函数\nmilliseconds   ：可选，执行或调用 code&#x2F;function 需要等待的时间，以毫秒计。默认为 0 ，最短为4ms\nparam1, param2 ：可选，传给执行函数的其他参数\n返回值          ：返回一个 ID（数字），可以将这个ID传递给 clearTimeout() 来取消执行const fun = (param1, param2) =&gt; &#123;  console.log(param1, param2);&#125;setTimeout(fun)setTimeout(fun, 1000, &#x27;param1&#x27;, &#x27;param2&#x27;)\n\n1.2 setInterval1.2.1 定义按照指定的周期（以毫秒计）来调用函数或计算表达式\n1.2.2 用法setInterval(code/function, milliseconds, param1, param2, ...)\n\n1.2.3 技术细节\ncode&#x2F;function\t ：必需，要调用一个代码串，也可以是一个函数\nmilliseconds   ：必需，周期性调用 code&#x2F;function 之间的时间间隔，以毫秒计，最短为10ms\nparam1, param2 ：可选，传给执行函数的其他参数\n返回值          ：返回一个 ID（数字），可以将这个ID传递给 clearInterval() 来取消执行const fun = (param1, param2) =&gt; &#123;  console.log(param1, param2);&#125;// setInterval(fun) //milliseconds 参数必须，否则疯狂执行代码块setInterval(fun, 1000, &#x27;param1&#x27;, &#x27;param2&#x27;)\n\n2 setInterval缺陷2.1 无视代码错误即使调用的代码报错了， setInterval 还是会周期性调用代码块\nlet count = 1setInterval(() =&gt; &#123;    count++    console.log(count);    if(count &gt; 3) throw new Error(&#x27;setInterval 报错&#x27;)&#125;, 1000)\n改用 setTimeout\nlet count = 0const fun = () =&gt;&#123;  setTimeout(() =&gt; &#123;    count++    console.log(count);    if(count &gt; 3) throw new Error(&#x27;setTimeout 报错&#x27;)    fun()  &#125;, 1000);&#125;fun()\n\n2.2 无视网络延迟在使用 Ajax 轮询服务器是否有新数据时，如果网络状态不佳，一个接口下发后还没有返回结果，此时 setInterval 还是会周期性调用代码块，导致客户端网络队列塞满 Ajax 请求\nconst http = () =&gt; &#123;  return new Promise((resolve) =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve()    &#125;, 3000);  &#125;)&#125;setInterval(async () =&gt; &#123;    await http()    console.log(&#x27;setInterval&#x27;);&#125;, 1000)\n改用 setTimeout\nconst http = () =&gt; &#123;  return new Promise((resolve) =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve()    &#125;, 3000);  &#125;)&#125;const fun = () =&gt;&#123;  setTimeout(async () =&gt; &#123;    await http();    console.log(&#x27;setTimeout&#x27;);    fun()  &#125;, 1000);&#125;fun()\n\n2.3 不保证间隔执行setInterval 周期性添加执行器到任务队列，如果调用的代码执行的时间大于设置时间间隔，它会跳过调用，这就导致漏执行\n3 优雅轮询递归调用 setTimeout() ，不需要后调用 clearTimeout() 清除定时器\nlet timer = nullconst interval = () =&gt; &#123;  timer = setTimeout(() =&gt; &#123;    // 执行代码块    interval()  &#125;, 1000)&#125;interval()// 清除setTimeout(() =&gt; &#123;  clearTimeout(timer)&#125;, 5000);","categories":["技术"],"tags":["JS"]},{"title":"Vue3 + Element Plus + i18n 国际化","url":"/2022/07/18/vue3-i18n/","content":"\n1 前言\n2 vue3 国际化\n3 element plus 国际化\n4 语言切换\n\n1 前言本篇旨在 Vue3 + Element Plus 国际化配置，支持多语言切换\n2 vue3 国际化2.1 安装 vue-i18npnpm i vue-i18n\n\n2.2 新建 locales 文件夹\n以简体中文和英文为例\n\n\n在 src 下新建 locales 文件夹\n在 locales 文件夹下新建 zh-cn.tsexport default &#123;  buttons: &#123;    login: &#x27;登录&#x27;  &#125;,  menus: &#123;    home: &#x27;首页&#x27;  &#125;&#125;\n在 locales 文件夹下新建 en.tsexport default &#123;  buttons: &#123;    login: &#x27;Login&#x27;  &#125;,  menus: &#123;    home: &#x27;Home&#x27;  &#125;&#125;\n在 locales 文件夹下新建 index.tsimport &#123; createI18n &#125; from &#x27;vue-i18n&#x27;import zhCn from &#x27;./zh-cn&#x27;import en from &#x27;./en&#x27;// 创建 i18nconst i18n = createI18n(&#123;  legacy: false,  globalInjection: true, // 全局模式，可以直接使用 $t  locale: localStorage.getItem(&#x27;lang&#x27;) || &#x27;zhCn&#x27;,  messages: &#123;    zhCn,    en  &#125;&#125;)export default i18n\n\n2.3 注册 i18n在 main.ts 文件下注册 i18n\nimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import i18n from &#x27;./locales&#x27;const app = createApp(App)app.use(i18n)app.mount(&#x27;#app&#x27;)\n\n2.4 使用方法2.4.1 在 template 中的使用&#123;&#123; $t(&#x27;menus.home&#x27;) &#125;&#125;\n\n2.4.2 在 ts 中的使用import i18n from &#x27;./locales&#x27;console.log(i18n.global.t(&#x27;menus.home&#x27;))\n\n3 element plus 国际化\nElement Plus 官方提供了一个 Vue 组件 ConfigProvider 用于全局配置国际化的设置el-config-provider 由 Vue3 + Element Plus 按需引入 - 自动导入el-config-provider 手动导入：import { ElConfigProvider } from ‘element-plus’\n\n&lt;template&gt;  &lt;el-config-provider :locale=&quot;useAppStoreHook().locale === &#x27;zhCn&#x27; ? zhCn : en&quot;&gt;    &lt;app /&gt;  &lt;/el-config-provider&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import zhCn from &#x27;element-plus/lib/locale/lang/zh-cn&#x27;import en from &#x27;element-plus/lib/locale/lang/en&#x27;import &#123; useAppStoreHook &#125; from &#x27;@/store/modules/app&#x27; //store存放语言配置&lt;/script&gt;\n\n4 语言切换\n切换语言时，修改 store 、 localstorage 和 i18n 中的语言配置\n\n// store/modules/appimport &#123; defineStore &#125; from &#x27;pinia&#x27;import &#123; store &#125; from &#x27;@/store&#x27;import i18n from &#x27;@/locales&#x27;const useAppStore = defineStore(&#x27;app&#x27;, &#123;  state: () =&gt; &#123;    return &#123;      locale: localStorage.getItem(&#x27;lang&#x27;) || &#x27;zhCn&#x27;    &#125;  &#125;,  actions: &#123;    SET_LOCALE(locale: string) &#123; //语言切换      this.locale = locale      storageLocal.setItem(&#x27;lang&#x27;, locale)      i18n.global.locale.value = locale    &#125;  &#125;&#125;)export function useAppStoreHook() &#123;  return useAppStore(store)&#125;","categories":["技术"],"tags":["Element Plus","Vue3"]},{"title":"Hexo 高级设置","url":"/2022/07/13/hexo-advanced/","content":"\n1 前言\n2 基本使用\n3 网站图标设置\n4 文章末尾打赏功能\n\n1 前言该篇旨在 Hexo 的高级设置，博客搭建请查看Hexo + GitHub 搭建个人博客\n2 基本使用2.1 跳转2.1.1 文章内跳转锚点 [文章内跳转](#目标位置)目标位置 &lt;span id=&quot;目标位置&quot;&gt;&lt;/span&gt;\n2.1.2 不同文章跳转&#123;% post_link 要跳转文章md文件名 %&#125;例：\n&#123;% post_link hexo %&#125;\n效果：\nHexo + GitHub 搭建个人博客\n\n2.2 新增文章模板2.2.1 在 scaffolds 文件夹下新增 post.md---title: &#123;&#123; title &#125;&#125;categories: 技术date: &#123;&#123; date &#125;&#125;tags:---[1. 前言](#前言)## 1 前言\n\n2.2.2 快速生成模板 MD 文件执行hexo new 文件名生成一个md文件\n3 网站图标设置3.1 判断主题是否已提供入口查看主题对应文件夹下的 head.ejs 文件是否有 &lt;link rel=&quot;icon&quot; href=&quot;&quot; /&gt; 标签，有该标签则已提供入口\n3.2 主题已提供入口3.2.1 查看入口标识\n3.2.2 修改主题站点配置文件注意，是修改主题站点配置文件，而不是根目录下的站点配置文件支持本地路径，也支持远程路径\n\n3.3 主题未提供入口3.3.1 制作图标使用比特虫来制作图标 ，也可以直接使用图片\n3.3.2 保存图标将 ico 文件或图片放置到主题对应的的 sources&#x2F;images 文件夹下\n3.3.3 修改 head.ejs 文件&lt;link rel=&quot;icon&quot; href=&quot;&lt;%= url_for(theme.favicon) %&gt;&quot; /&gt;\n\n3.3.4 修改主题站点配置文件favicon: &#x27;/images/favicon.ico&#x27;\n\n4 文章末尾打赏功能4.1 主题自带打赏功能4.1.1 准备收款码将微信、支付宝收款码图片放到主题文件夹下的 images 文件夹里，可以使用草料二维码进行美化\n4.1.2 修改主题站点配置文件#查看主题文档，确定主题是否支持打赏功能，以及打赏对应配置#以 NexT 主题为例reward:  enable: true  comment: 您的鼓励，是我最大的动力！  wechatpay: /images/wechatpay.jpg  alipay: /images/alipay.jpg\n\n4.2 自定义打赏功能4.2.1 准备收款码操作同上\n4.2.2 新增 reward.ejs 文件在主题文件夹下新增 reward.ejs 文件，并将以下内容复制到新增文件中\n&lt;div class=&quot;reward-container&quot;&gt;  &lt;% if(theme.reward.pay_links) &#123; %&gt;  &lt;span class=&quot;reward-button&quot;&gt;&lt;%=theme.reward.title%&gt;&lt;/span&gt;  &lt;div&gt;&lt;%=theme.reward.message%&gt;&lt;/div&gt;  &lt;div class=&quot;reward-pay&quot;&gt;    &lt;% for(const item of theme.reward.pay_links) &#123; %&gt;    &lt;div style=&quot;margin: 10px&quot;&gt;      &lt;img src=&quot;&lt;%= url_for(item.link) %&gt;&quot; alt=&quot;&lt;%= item.type %&gt;&quot; /&gt;    &lt;/div&gt;    &lt;% &#125; %&gt;  &lt;/div&gt;  &lt;% &#125; %&gt;&lt;/div&gt;&lt;script&gt;  const rewardButtonDom = document.getElementsByClassName(&#x27;reward-button&#x27;)[0]  const rewardPayDom = document.getElementsByClassName(&#x27;reward-pay&#x27;)[0]  rewardButtonDom.addEventListener(&#x27;click&#x27;, function () &#123;    rewardPayDom.style.display =      rewardPayDom.style.display === &#x27;flex&#x27; ? &#x27;none&#x27; : &#x27;flex&#x27;  &#125;)&lt;/script&gt;\n\n4.2.3 新增样式文件在主题文件夹下新增 _partial 文件夹，并在新增文件夹里新建 index.styl 、 reward.styl 文件将以下内容复制到 reward.styl\n.reward-container &#123;  margin: 30px 0 20px;  text-align: center;  .reward-button &#123;    display: inline-block;    color: #fff;    background-color: #ec7259;    font-size: 16px;    padding: 8px 16px;    border-radius: 20px;    cursor: pointer;    user-select: none;  &#125;  .reward-pay &#123;    display: none;    flex-wrap: wrap;    justify-content: center;    position: relative;    img &#123;        max-width: 150px;    &#125;  &#125;&#125;\n将以下内容复制到 index.styl\n@import &quot;reward&quot;\n\n4.2.4 注册样式文件在主题文件夹下的 css 文件夹里，找到全局注册样式文件，可能是 main.styl ，也可能是 index.styl ，需要自行判断注册 _partial 样式文件 @import &quot;_partial/index&quot;\n4.2.5 在文章底部插入打赏组件找到项目显示博客文章所对应的 ejs 文件，例如本博客所用主题对应的 ejs 文件是 post.ejs\n\n小窍门：先确定打赏组件在文章中的显示位置，然后复制位置附近的文字全局搜索，快速确定项目显示博客文章所对应的 ejs 文件\n\n将以下内容插入到文件的合适位置\n&lt;% if(theme.reward.enable) &#123; %&gt;  &lt;%- partial(&#x27;_partial/reward&#x27;) %&gt;&lt;% &#125; %&gt;\n\n4.2.6 修改主题站点配置文件将以下内容复制到主题站点配置文件\nreward:  enable: true  title: 赞赏支持  message: 您的鼓励，是我最大的动力！  pay_links:    - &#123; type: 微信, link: /images/wechatpay.png &#125;    - &#123; type: 支付宝, link: /images/alipay.png &#125;\n","categories":["技术"],"tags":["Hexo"]},{"title":"Vue3 + Element Plus 按需引入 - 自动导入","url":"/2022/07/11/element-plus-auto-import/","content":"\n1 前言\n2 准备工作\n3 按需引入\n4 其他\n\n1 前言1.1 目的Element Plus 使用按需引入，大大缩小打包后的文件大小\n1.2 最终效果自动生成 components.d.ts 文件，并在文件中引入 Element Plus 组件自动生成 components.d.ts 文件，并在文件中引入 Element Plus API\n2 准备工作安装 Element Plus\n# 选择一个你喜欢的包管理器# NPM$ npm install element-plus --save# Yarn$ yarn add element-plus# pnpm$ pnpm install element-plus\n3 按需引入3.1 安装插件\n组件按需引入所需插件：unplugin-auto-import 、 unplugin-vue-components\n图标按需引入所需插件：unplugin-auto-import 、 unplugin-icons只需要安装到开发环境\n$ pnpm i unplugin-auto-import unplugin-vue-components unplugin-icons -D\n\n3.2 修改 vite.config.ts 文件\n4 其他4.1 ElMessageBox 使用时报错4.1.1 Eslint 报错： ‘ElMessageBox’ is not defined.eslint(no-undef)\n修改 vite.config.ts 配置： AutoImport 增加 eslintrc ，自动生成 .eslintrc-auto-import.json 文件\n\n\n\n修改 .eslintrc.js 配置： \n\n\n4.1.2 TS 报错： Cannot find name ‘ElMessageBox’\n修改 tsconfig.json 配置： include 中增加 “.&#x2F;auto-imports.d.ts”\n\n&quot;include&quot;: [  &quot;src/**/*.ts&quot;,  &quot;src/**/*.d.ts&quot;,  &quot;src/**/*.tsx&quot;,  &quot;src/**/*.vue&quot;,  &quot;./auto-imports.d.ts&quot;], \n\n\n\n\n4.2 ElMessageBox 弹框样式未生效\n使用按需引入后，不能再手动引入 ElMessageBox ，否则会引起样式冲突，需要删除手动引入 ElMessageBox 部分代码\n\n4.3 图标使用注意，-ep- 是 vite.config.ts 文件中配置的，必须保持一致\n&lt;!-- 直接使用 --&gt;&lt;i-ep-menu /&gt;&lt;!-- 嵌套使用 --&gt;&lt;el-icon&gt;&lt;i-ep-menu /&gt;&lt;/el-icon&gt;\n","categories":["技术"],"tags":["Element Plus","Vue3"]},{"title":"Hexo + GitHub 搭建个人博客","url":"/2022/07/04/hexo/","content":"\n1 前言\n2 准备工作\n3 博客搭建\n4 主题修改\n\n1 前言1.1 目的记录日常开发、学习过程中遇到的问题，方便后续查看\n1.2 最终效果通过网址 https:&#x2F;&#x2F;your username.github.io 直接访问搭建好的博客\n1.3 高级设置该篇旨在博客搭建，高级设置请查看Hexo 高级设置\n2 准备工作2.1 基本环境\nGitHub 账号\nNode.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)\nGit\n\n2.2 创建博客对应的 GitHub 仓库\n仓库名称必须为your username.github.io\n必须为 public 仓库，否则访问博客会404\n下图中我的username是yanadh，那么对应的仓库名称就是yanadh.github.io\n\n3 博客搭建3.1 安装 Hexo$ npm i hexo -g\n\n3.2 初始化$ hexo init\n执行该命令，Hexo 自动下载相关文件到本地\n3.3 预览$ hexo s\n浏览器访问 http://localhost:4000/ ，即可查看本地博客效果，除修改 _config.yml 站点配置文件外，其他文件更改无需重启服务器，可直接刷新查看\n3.4 发布3.4.1 安装插件$ npm i hexo-deployer-git\n\n3.4.2 修改站点配置文件在根目录下找到 _config.yml ，修改最下方 deploy 内容\ndeploy:  type: git  repo: `your username`.github.io 仓库  branch: 分支名例如：deploy:  type: git  repo: git@github.com:YanaDH/yanadh.github.io.git  branch: master\n\n3.4.3 将静态文件推送到 GitHub 仓库$ hexo g -d\n\n执行该命令，生成静态网页文件存放在 public 文件夹下，并推送到 _config.yml 文件 deploy.repo 配置的仓库以上命令执行成功后，浏览器访问 https:&#x2F;&#x2F;your username.github.io ，即可查看博客部署需要时间，若刷新后无效，等待一段时间再试\n\n4 主题修改4.1 下载主题可以在 Hexo 官网上选择一款喜欢的主题，并克隆到 themes 文件夹下\n$ git clone https://github.com/theme-kaze/hexo-theme-kaze.git\n\n4.2 修改站点配置文件在根目录下找到 _config.yml ，修改最下方 theme 内容\ntheme: 主题文件夹名称例如：theme: hexo-theme-Mic_Theme\n\n4.3 修改主题内容可直接到主题对应的 GitHub 提供的文档查看具体修改内容：hexo-theme-Mic_Theme\n","categories":["技术"],"tags":["Hexo","GitHub"]},{"title":"搭建个人脚手架","url":"/2022/07/01/yana-cli/","content":"\n1 前言\n2 目录结构\n3 创建命令\n4 简化命令解析\n5 新增list命令\n6 新增create命令\n7 发布npm包\n8 脚手架优化\n9 自动部署\n\n1 前言1.1 目的使项目快速进入开发阶段，解决万事开头难的问题\n1.2 最终效果通过运行命令，从远端下载代码模板，并能自定义文件夹名称、package.json的部分信息\n2 目录结构GitHubGitee\n├── package.json├── template.json├── node_modules├── bin│   └── yana-cli.js                                     # 命令脚本├── lib│   ├── util│   │   ├── generator.js│   │   └── git-user.js│   ├── create.js                                       # 选择一个模板生成项目│   └── list.js                                         # 查看模板列表\n\n3 创建命令尽量不要使用 Git Bash ，可能会有箭头、颜色等失效问题，直接使用 CMD\n\n3.1 package.json 文件初始化$ npm init --yes\n\n3.2 新建 yana-cli.js\n根目录下新建 bin 文件夹\n在 bin 文件夹下新建 yana-cli.js\n将以下内容粘贴到 yana-cli.js#! usr/bin/env nodeconsole.log(process.argv)\n\n#! usr&#x2F;bin&#x2F;env node ：这行代码不可删除，告诉系统当前脚本由 Node.js 来解析执行\n\n\n\n3.3 添加命令路径在根目录下找到 package.json ，添加 bin 字段\n&quot;bin&quot;: &#123;  &quot;yana-cli&quot;: &quot;bin/yana-cli.js&quot;&#125;\n\n3.4 添加软链接$ npm link\n\n执行该命令，增加软链接到全局，成功后可直接全局使用 yana-cli\n若该命令执行失败，可以在网上查看对应解决方案\n最终无法成功执行，可直接使用 node bin/yana-cli 代替后续 yana-cli 执行命令\n\n3.5 测试命令$ yana-cli\n成功输出以下内容\n[  &#x27;xxx\\xxx\\node.exe&#x27;,  &#x27;xxx\\xxx\\bin\\yana-cli&#x27;]\n\n4 简化命令解析4.1 安装 commander$ npm i commander\n\n4.2 修改 yana-cli.js 文件#! /usr/bin/env nodeconst program = require(&#x27;commander&#x27;)const config = require(&#x27;../package.json&#x27;)program.version(config.version, &#x27;-v, --version&#x27;)// 定义使用方法program  .command(&#x27;create&#x27;)  .description(&#x27;选择模板生成项目&#x27;)  .action(() =&gt; &#123;    require(&#x27;../lib/create&#x27;)  &#125;)program  .command(&#x27;list&#x27;)  .description(&#x27;查看当前可用模板&#x27;)  .action(() =&gt; &#123;    require(&#x27;../lib/list&#x27;)  &#125;)// 解析参数program.parse(process.argv)if (!program.args.length) &#123;  program.help()&#125;\n执行 yana-cli 输出以下内容\n5 新增list命令5.1 新建 list.js 文件\n根目录下新建 lib 文件夹\n在 lib 文件夹下新建 list.js\n将以下内容粘贴到 list.jsconst template = require(&#x27;../template.json&#x27;)console.log(&#x27;当前模板列表如下：\\n&#x27;)console.log(template)\n\n5.2 新建 template.json 文件\n根目录下新建 template.json 文件\n将以下内容粘贴到 template.json&#123;&quot;vue3-project-template&quot;:&quot;https://gitee.com/YanaDH/vue3-project-template.git&quot;&#125;\n执行 yana-cli list 输出以下内容\n\n6 新增create命令6.1 安装插件$ npm i download-git-repo inquirer handlebars\n\ndownload-git-repo ：执行 git clone 克隆模板仓库\ninquirer 根据用户输入内容自定义模板\nhandlebars 替换 package.json 中项目元信息\npackage.json 指的是 template.json 文件配置的vue3-project-template模板仓库里的 package.json 文件，需要被替换的地方需要使用&#123;&#123;&#125;&#125;包裹起来\n\n\n\n\n6.2 新建 create.js\n在 lib 文件夹下新建 create.js\n将以下内容粘贴到 create.jsconst templateUrl = require(&#x27;../template.json&#x27;)[&#x27;vue3-project-template&#x27;]const download = require(&#x27;download-git-repo&#x27;)const inquirer = require(&#x27;inquirer&#x27;)// 新增项const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)const handlebars = require(&#x27;handlebars&#x27;)download(`direct:$&#123;templateUrl&#125;`, &#x27;tmp&#x27;, &#123; clone: true &#125;, (err) =&gt; &#123;  if (err) return  const packagePath = path.join(__dirname, &#x27;../&#x27;, &#x27;/tmp/package.json&#x27;)  const content = JSON.stringify(require(packagePath), &#x27;&#x27;, &#x27;\\t&#x27;)  const template = handlebars.compile(content)  inquirer    .prompt([      &#123; name: &#x27;name&#x27;, message: &#x27;请输入项目名称&#x27; &#125;,      &#123; name: &#x27;description&#x27;, message: &#x27;请输入项目描述&#x27; &#125;,      &#123; name: &#x27;author&#x27;, message: &#x27;请输入项目作者&#x27; &#125;,    ])    .then((params) =&gt; &#123;      const result = template(params)      fs.writeFileSync(packagePath, result)      console.log(params)    &#125;)&#125;)\n\n6.3 create 命令测试$ yana-cli create\n若 inquirer 报错，则降低 inquirer 版本为8.2.4终端输出以下内容对应目录生成 tmp 文件夹，且下载下来的模板仓库 package.json 文件中 name、description、author 为刚刚输入内容\n7 发布npm包若没有npm账号，需要先注册一个\n# 1. 登录npm，输入用户名、密码$ npm login# 2. 发布$ npm publish\n发布成功后可直接通过 npm i yana-cli 进行安装\n8 脚手架优化GitHubGitee\n8.1 安装插件$ npm i chalk ora metalsmith\n\nchalk ：给控制台打印内容添加颜色\nora ：给控制台打印内容添加loading\nmetalsmith ：自定义文件夹名称\n\n8.2 新增 generator.js 文件替换 package.json 文件中的 name、description、author\n\n在 bin 文件夹下 util 文件夹\n在 util 文件夹下新建 generator.js 文件\n将链接内容粘贴到 generator.js\n\n8.3 新增 git-user.js 文件直接将 package.json 文件中的 author 设置为本地 Git 配置的用户名\n\n在 util 文件夹下新建 git-user.js 文件\n将链接内容粘贴到 git-user.js\n\n8.4 修改 create.js 文件中控制台增加颜色、loading等显示将链接内容粘贴到 create.js\n$ yana-cli create\n\n若 ora 报错，则将 ora 版本降为8.2.4\n若 chalk 报错，则将 chalk 版本降为4.1.1\n\n9 自动部署9.1 获取 NPM TOKEN\n在npm生成 NPM TOKEN\n\n\n9.2 配置 NPM TOKEN将 yana-cli 脚手架项目推到 GitHub ，并将生成的 NPM TOKEN 配置到 GitHub 对应仓库\n9.3 添加 Action 脚本\n\n将以下内容粘贴到 mian.yml\n其中NODE_AUTH_TOKEN对应的值secrets.npm_token中npm_token需要与上一步骤配置的NPM TOKEN 名称一致\n当有代码 push 到仓库时， Action 脚本将会自动执行，将包发布到 NPMname: Publish To Npmon:  push:    branches: [ &quot;master&quot; ] jobs:  publish-npm:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v2      - uses: actions/setup-node@v1        with:          node-version: &quot;12.x&quot;          registry-url: https://registry.npmjs.org/      - run: npm publish        env:          NODE_AUTH_TOKEN: $&#123;&#123;secrets.npm_token&#125;&#125;\n\n","categories":["技术"],"tags":["Cli"]}]