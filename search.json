[{"title":"Vue3 + Element Plus 实现大文件切片上传及进度条展示","url":"/2022/11/18/chunk-upload/","content":"\n1 前言\n2 功能实现\n3 完整代码\n4 拓展\n\n1 前言最近在做一个项目的重构，其中有大文件上传的功能，由于项目是几年前，代码没有前后分离，用的是 jQuery + webuploader 库做的，但实际上只是实现了大文件切片上传，并没有切片并发、秒传及断点续传功能，后端也不支持，且 webuploader 库已经不再维护了，故决定自己实现一个最简单的大文件切片上传功能。\n2 功能实现2.1 添加 Element Plus 上传代码及进度条展示代码&lt;template&gt;  &lt;el-upload    accept=&quot;.mp3, .m4a, .aac, .mp4, .m4v&quot;    :before-upload=&quot;beforeUpload&quot;    :http-request=&quot;upload&quot;    :show-file-list=&quot;false&quot;    :disabled=&quot;disabled&quot;    style=&quot;display: inline-block&quot;  &gt;    &lt;el-tooltip placement=&quot;bottom&quot;&gt;      &lt;template #content&gt;        可上传本地录音录像，支持上传的        &lt;br /&gt;音频格式为：mp3、m4a、aac        &lt;br /&gt;        视频格式为：mp4、m4v      &lt;/template&gt;      &lt;el-button type=&quot;primary&quot; :disabled=&quot;disabled&quot;&gt;        上传录音录像      &lt;/el-button&gt;    &lt;/el-tooltip&gt;  &lt;/el-upload&gt;  &lt;el-dialog    v-model=&quot;dialogVisible&quot;    :fullscreen=&quot;true&quot;    :show-close=&quot;false&quot;    custom-class=&quot;dispute-upload-dialog&quot;  &gt;    &lt;div class=&quot;center&quot;&gt;      &lt;div class=&quot;fz-18 ellipsis&quot;&gt;正在上传：&#123;&#123; fileData.name &#125;&#125;&lt;/div&gt;      &lt;el-progress :text-inside=&quot;true&quot; :stroke-width=&quot;16&quot; :percentage=&quot;percentage&quot; /&gt;      &lt;el-button @click=&quot;cancel&quot;&gt;取消上传&lt;/el-button&gt;    &lt;/div&gt;  &lt;/el-dialog&gt;&lt;/template&gt;\n\n2.2 限制文件上传类型和大小const beforeUpload = (file: File) =&gt; &#123;  const mimeTypes = [&#x27;audio/mpeg&#x27;, &#x27;audio/x-m4a&#x27;, &#x27;audio/aac&#x27;, &#x27;video/mp4&#x27;, &#x27;video/x-m4v&#x27;]  if (!mimeTypes.includes(file.type)) &#123;    ElMessage(&#123;      type: &#x27;error&#x27;,      message: &#x27;只能上传 MP3、M4A、AAC、MP4、M4V 格式的文件&#x27;,      duration: 6000    &#125;)    return false  &#125;  if (file.size / 1024 / 1024 / 1024 &gt; 1.5) &#123;    ElMessage.error(&#x27;文件大小不能超过 1.5G&#x27;)    ElMessage(&#123;      type: &#x27;error&#x27;,      message: &#x27;文件大小不能超过 1.5G&#x27;,      duration: 6000    &#125;)    return false  &#125;  return true&#125;\n\n2.3 判断文件大小，小文件直接上传const chunkSize = 1 * 1024 * 1024 // 切片大小const upload = async (file: &#123; file: File &#125;) =&gt; &#123;  const fileObj = file.file  const nameList = fileObj.name.split(&#x27;.&#x27;)  fileData.value.name = fileObj.name  fileData.value.size = fileObj.size  fileData.value.type = fileObj.type  fileData.value.suffix = nameList[nameList.length - 1]  if (chunkSize &gt; fileData.value.size) &#123; // 文件大小小于切片大小，直接上传    disabled.value = true    axios      .post(&#x27;upload&#x27;, fileObj) // 调用后端上传文件接口      .then((res) =&gt; &#123;        ElMessageBox(&#123; message: `$&#123;fileData.value.name&#125;上传成功`, title: &#x27;提示&#x27; &#125;)        updateUrl(res.data) // 调用后端保存上传文件路径接口      &#125;)      .catch(() =&gt; ElMessageBox(&#123; message: `$&#123;fileData.value.name&#125;上传失败`, title: &#x27;提示&#x27; &#125;)) // 上传失败弹框      .finally(() =&gt; (disabled.value = false))    return  &#125;  batchUpload(fileObj) // 大文件切片上传&#125;\n\n2.4 大文件获取文件唯一标识// 重构项目没有断点续传等功能，故不需要做hash计算，只需要保证唯一即可，后端会拿这个值新建文件夹保存切片let counter = 0const getFileMd5 = () =&gt; &#123;  let guid = (+new Date()).toString(32)  for (let i = 0; i &lt; 5; i++) &#123;    guid += Math.floor(Math.random() * 65535).toString(32)  &#125;  return &#x27;wu_&#x27; + guid + (counter++).toString(32)&#125;\n\n2.5 上传切片let controller: AbortController | null = null // 当前切片上传 AbortControllerconst uploadChunkFile = async (i: number, fileObj: File) =&gt; &#123;  const start = i * chunkSize // 切片开始位置  const end = Math.min(fileData.value.size, start + chunkSize) // 切片结束位置  const chunkFile = fileObj.slice(start, end) // 切片文件  const formData = new FormData() // formData 参数需要与后端对齐  formData.append(&#x27;fileName&#x27;, fileData.value.name)  formData.append(&#x27;folder&#x27;, fileData.value.md5)  formData.append(&#x27;file&#x27;, chunkFile, String(i + 1)) // 必传字段；若第三个参数不传，切片 filename 默认是 blob ，如果后端是以切片名称来做合并的，则第三个参数一定要传  controller = new AbortController() // 每一次上传切片都要新生成一个 AbortController ，否则重新上传会失败  return await axios    .post(&#x27;mergeUpload&#x27;, formData, &#123; // 调用后端上传切片接口      onUploadProgress: (data) =&gt; &#123; // 进度条展示        percentage.value = Number(          (            (Math.min(fileData.value.size, start + data.loaded) / fileData.value.size) *            100          ).toFixed(2)        )      &#125;,      signal: controller.signal // 取消上传    &#125;)    .then((res) =&gt; updateUrl(res.data))&#125;const percentage = ref(0)const dialogVisible = ref(false)const cancelUpload = ref(false)const batchUpload = async (fileObj: File) =&gt; &#123;  percentage.value = 0 // 每次上传文件前清空进度条  dialogVisible.value = true // 显示上传进度  cancelUpload.value = false // 每次上传文件前将取消上传标识置为 false  const chunkCount = Math.ceil(fileData.value.size / chunkSize) // 切片数量  fileData.value.md5 = getFileMd5() // 文件唯一标识  for (let i = 0; i &lt; chunkCount; i++) &#123;    if (cancelUpload.value) return // 若已经取消上传，则不再上传切片    const res = await uploadChunkFile(i, fileObj) // 上传切片    if (res.code !== 0) &#123; // 切片上传失败      dialogVisible.value = false      ElMessageBox(&#123; message: `$&#123;fileData.value.name&#125;上传失败`, title: &#x27;提示&#x27; &#125;)      return    &#125;    if (i === chunkCount - 1) &#123; // 最后一片切片上传成功      setTimeout(() =&gt; &#123; // 延迟关闭上传进度框用户体验会更好        dialogVisible.value = false        ElMessageBox(&#123; message: `$&#123;fileData.value.name&#125;上传成功`, title: &#x27;提示&#x27; &#125;)        axios.post(&#x27;mergeUpload&#x27;, &#123; folder: fileData.value.md5 &#125;) // 调用后端合并切片接口，参数需要与后端对齐          .then((res) =&gt; updateUrl(res.data)) // 调用后端保存上传文件路径接口      &#125;, 500)    &#125;  &#125;&#125;\n\n2.6 取消上传const cancel = () =&gt; &#123;  dialogVisible.value = false  cancelUpload.value = true  controller?.abort()  axios.post(&#x27;cancelUpload&#x27;, &#123; folder: fileData.value.md5 &#125;) // 调用后端接口，删除已上传的切片&#125;\n\n3 完整代码&lt;template&gt;  &lt;el-upload    accept=&quot;.mp3, .m4a, .aac, .mp4, .m4v&quot;    :before-upload=&quot;beforeUpload&quot;    :http-request=&quot;upload&quot;    :show-file-list=&quot;false&quot;    :disabled=&quot;disabled&quot;    style=&quot;display: inline-block&quot;    class=&quot;m-x-12&quot;  &gt;    &lt;el-tooltip placement=&quot;bottom&quot;&gt;      &lt;template #content&gt;        可上传本地录音录像，支持上传的        &lt;br /&gt;音频格式为：mp3、m4a、aac        &lt;br /&gt;        视频格式为：mp4、m4v      &lt;/template&gt;      &lt;el-button type=&quot;primary&quot; style=&quot;font-size: 12px&quot; :disabled=&quot;disabled&quot;&gt;        上传录音录像      &lt;/el-button&gt;    &lt;/el-tooltip&gt;  &lt;/el-upload&gt;  &lt;el-dialog    v-model=&quot;dialogVisible&quot;    :fullscreen=&quot;true&quot;    :show-close=&quot;false&quot;    custom-class=&quot;dispute-upload-dialog&quot;  &gt;    &lt;div class=&quot;center&quot;&gt;      &lt;div class=&quot;fz-18 ellipsis&quot;&gt;正在上传：&#123;&#123; fileData.name &#125;&#125;&lt;/div&gt;      &lt;el-progress :text-inside=&quot;true&quot; :stroke-width=&quot;16&quot; :percentage=&quot;percentage&quot; /&gt;      &lt;el-button @click=&quot;cancel&quot;&gt;取消上传&lt;/el-button&gt;    &lt;/div&gt;  &lt;/el-dialog&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import axios from &#x27;axios&#x27;const beforeUpload = (file: File) =&gt; &#123;  const mimeTypes = [&#x27;audio/mpeg&#x27;, &#x27;audio/x-m4a&#x27;, &#x27;audio/aac&#x27;, &#x27;video/mp4&#x27;, &#x27;video/x-m4v&#x27;]  if (!mimeTypes.includes(file.type)) &#123;    ElMessage(&#123;      type: &#x27;error&#x27;,      message: &#x27;只能上传 MP3、M4A、AAC、MP4、M4V 格式的文件&#x27;,      duration: 6000    &#125;)    return false  &#125;  if (file.size / 1024 / 1024 / 1024 &gt; 1.5) &#123;    ElMessage.error(&#x27;文件大小不能超过 1.5G&#x27;)    ElMessage(&#123;      type: &#x27;error&#x27;,      message: &#x27;文件大小不能超过 1.5G&#x27;,      duration: 6000    &#125;)    return false  &#125;  return true&#125;const dialogVisible = ref(false)const cancelUpload = ref(false)let controller: AbortController | null = nullconst chunkSize = 1 * 1024 * 1024 // 切片大小const percentage = ref(0)const fileData = ref(&#123;  name: &#x27;&#x27;,  size: 0,  type: &#x27;&#x27;,  suffix: &#x27;&#x27;,  md5: &#x27;&#x27;&#125;)const cancel = () =&gt; &#123;  dialogVisible.value = false  cancelUpload.value = true  controller?.abort()  axios.post(&#x27;cancelUpload&#x27;, &#123; folder: fileData.value.md5 &#125;)&#125;let counter = 0const getFileMd5 = () =&gt; &#123;  let guid = (+new Date()).toString(32)  for (let i = 0; i &lt; 5; i++) &#123;    guid += Math.floor(Math.random() * 65535).toString(32)  &#125;  return &#x27;wu_&#x27; + guid + (counter++).toString(32)&#125;const updateUrl = (fileUrl: string) =&gt; &#123;  axios.post(&#x27;saveUrl&#x27;, &#123;    fileName: fileData.value.name,    fileUrl  &#125;)&#125;const uploadChunkFile = async (i: number, fileObj: File) =&gt; &#123;  const start = i * chunkSize  const end = Math.min(fileData.value.size, start + chunkSize)  const chunkFile = fileObj.slice(start, end)  const formData = new FormData()  formData.append(&#x27;encrypt&#x27;, &#x27;true&#x27;)  formData.append(&#x27;fileName&#x27;, fileData.value.name)  formData.append(&#x27;folder&#x27;, fileData.value.md5)  formData.append(&#x27;file&#x27;, chunkFile, String(i + 1))  controller = new AbortController()  return await axios    .post(&#x27;mergeUpload&#x27;, formData, &#123;      onUploadProgress: (data) =&gt; &#123;        percentage.value = Number(          (            (Math.min(fileData.value.size, start + data.loaded) / fileData.value.size) *            100          ).toFixed(2)        )      &#125;,      signal: controller.signal    &#125;)    .then((res) =&gt; updateUrl(res.data))&#125;const batchUpload = async (fileObj: File) =&gt; &#123;  percentage.value = 0  dialogVisible.value = true  cancelUpload.value = false  const chunkCount = Math.ceil(fileData.value.size / chunkSize) // 切片数量  fileData.value.md5 = getFileMd5() // 文件唯一标识  for (let i = 0; i &lt; chunkCount; i++) &#123;    if (cancelUpload.value) return    const res = await uploadChunkFile(i, fileObj)    if (res.code !== 0) &#123;      dialogVisible.value = false      ElMessageBox(&#123; message: `$&#123;fileData.value.name&#125;上传失败`, title: &#x27;提示&#x27; &#125;)      return    &#125;    if (i === chunkCount - 1) &#123;      setTimeout(() =&gt; &#123;        dialogVisible.value = false        ElMessageBox(&#123; message: `$&#123;fileData.value.name&#125;上传成功`, title: &#x27;提示&#x27; &#125;)        axios.post(&#x27;mergeUpload&#x27;, &#123; folder: fileData.value.md5 &#125;).then((res) =&gt; updateUrl(res.data))      &#125;, 500)    &#125;  &#125;&#125;const disabled = ref(false)const upload = async (file: &#123; file: File &#125;) =&gt; &#123;  const fileObj = file.file  const nameList = fileObj.name.split(&#x27;.&#x27;)  fileData.value.name = fileObj.name  fileData.value.size = fileObj.size  fileData.value.type = fileObj.type  fileData.value.suffix = nameList[nameList.length - 1]  if (chunkSize &gt; fileData.value.size) &#123;    disabled.value = true    axios      .post(&#x27;upload&#x27;, fileObj)      .then((res) =&gt; &#123;        ElMessageBox(&#123; message: `$&#123;fileData.value.name&#125;上传成功`, title: &#x27;提示&#x27; &#125;)        updateUrl(res.data)      &#125;)      .catch(() =&gt; ElMessageBox(&#123; message: `$&#123;fileData.value.name&#125;上传失败`, title: &#x27;提示&#x27; &#125;))      .finally(() =&gt; (disabled.value = false))    return  &#125;  batchUpload(fileObj)&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;.dispute-upload-dialog &#123;  background: none;&#125;&lt;/style&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.center &#123;  color: #fff;  width: 50%;  text-align: center;  position: absolute;  top: 50%;  left: 50%;  transform: translate(-50%, -50%);&#125;&lt;/style&gt;\n\n4 拓展\nhash 值作为文件唯一标识引入 js-spark-md5 库做文件 hash 计算\n切片并发上传需要控制好并发数量\n秒传上传文件前请求后端接口，通过文件 hash 值判断否存已经上传过该文件，存在则无需再上传该文件，直接返回上传成功，实现秒传\n断点续传上传切片前请求后端接口，通过切片 hash 值判断是否已经上传过该切片，存在则无需再上传该切片，从下一个切片开始上传，实现断点续传\n\n","categories":["技术"],"tags":["Element Plus","Vue3"]},{"title":"Vue3 + PDF.js 实现 PDF 预览","url":"/2022/11/03/pdfJs-md/","content":"\n1 前言\n2 PDF 预览测试\n3 修改配置项\n4 移除部分按钮\n5 错误处理\n\n1 前言PDF.js 官网\n\n本文使用的 PDF.js 版本为：v3.0.279\n本文未使用 npm 形式在项目中引入 PDF.js 依赖，因为该形式引入的 PDF.js 需要自己写额外页面样式及按钮，而直接在官网下载可以使用 PDF.js 默认提供的 viewer ，不用再增加额外代码，即可实现 PDF 预览等功能# 使用 npm 形式在项目中引入 PDF.js 依赖npm i pdfjs-dist\n效果预览\n\n2 PDF 预览测试2.1 下载 PDF.js在 PDF.js 官网下载 PDF.js ，解压后放到 public&#x2F;static 下\n2.2 window.open 直接打开// 默认打开 public/static/pdf/web/compressed.tracemonkey-pldi-09.pdf// 测试 pdf 有点大，第一次打开可能会有点慢，只要有进度条就是正常加载中window.open(&#x27;static/pdf/web/viewer.html&#x27;)// 传入 pdf 文件地址const fileUrl = &#x27;xxx&#x27;window.open(&#x27;static/pdf/web/viewer.html?file=&#x27; + fileUrl)\n\n2.3 弹框形式打开&lt;el-dialog v-model=&quot;dialogVisible&quot;&gt;  &lt;iframe :src=&quot;&#x27;static/pdf/web/viewer.html?file=&#x27; + fileUrl&quot;    style=&quot;width: 100%; height: 440px&quot;  &gt;&lt;/iframe&gt;&lt;/el-dialog&gt;\n\n3 修改配置项3.1 修改主题色为暗色系修改 public&#x2F;static&#x2F;pdf&#x2F;web&#x2F;viewer.js\nAUTOMATIC: 0, // 跟随浏览器LIGHT: 1, // 亮色DARK: 2 // 暗色\n\n3.2 修改默认语言为简体中文修改 public&#x2F;static&#x2F;pdf&#x2F;web&#x2F;viewer.js\n3.3 打开 PDF 后默认跳转到某一页// 添加 #page=2 默认跳转到第二页window.open(&#x27;static/pdf/web/viewer.html?file=&#x27; + fileUrl + &#x27;#page=2&#x27;)\n\n4 移除部分按钮4.1 简单按钮移除例：移除[打印]按钮\n4.2 复杂按钮移除例：移除[文本]按钮，由于该按钮点击后会出现面板，所以除了移除当前按钮相关代码外，还要移除面板相关代码\n5 错误处理5.1 跨域报错注释 public&#x2F;static&#x2F;pdf&#x2F;web&#x2F;viewer.js 代码\n5.2 默认语言为简体中文，但下载按钮仍显示为“Save”修改 public&#x2F;static&#x2F;pdf&#x2F;web&#x2F;viewer.html 第159、276行代码如果需要使用到以下两种语言，也需要将 save_label 改为 download_label\n","categories":["技术"],"tags":["Vue3"]},{"title":"Node.js 入门 —— fs 文件系统模块","url":"/2022/10/28/node-221028/","content":"\n1 前言\n2 Node.js 简介\n3 什么是终端\n4 fs 文件系统模块\n\n1 前言本文内容来自bilibili 黑马程序员 \n1.1 为什么 JavaScript 可以在浏览器中被执行？\n浏览器中有 JS 解析引擎Chrome： V8Firefox：OdinMonkey（奥丁猴）Safari：JSCoreIE：Charka（查克拉）\n\n\n1.2 为什么 JavaScript 可以操作 DOM 和 BOM\n每个浏览器都内置了 DOM 和 BOM 这样的 API 函数，因此，浏览器中的 JavaScript 才可以调用它们\n\n\n1.3 浏览器中的 JavaScript 运行环境\n运行环境指的是代码正常运行所需的必要环境V8 引擎负责解析和执行 JavaScript 代码内置的 API 是由运行环境提供的特殊接口，只能在所属的运行环境中被调用\n\n\n1.4 JavaScript 是否能做后端\n可以，Node.js 提供运行环境\n\n2 Node.js 简介2.1 什么是 Node.jsNode 官网\n\nNode.js 是一个基于 Chrome V8 引擎的 JavaScript运行环境\n\n2.2 Node.js 中的 JavaScript 运行环境\n浏览器是 JavaScript 的前端运行环境Node.js 是 JavaScript 的后端运行环境Node.js 中无法调用 DOM、BOM 等浏览器内置 API\n\n\n2.3 Node.js 学习路径\n浏览器中的 JavaScript 学习路径：JavaScript 基础语法 ＋ 浏览器内置 API (DOM + BOM)＋第三方库 (jQuery、art-template 等）\n\n\nNode.js 的学习路径：JavaScript 基础语法 + Nodejs 内置 API 模块（fs、path、http 等）＋ 第三方 API 模块(express. mysal 等）\n\n3 什么是终端\n终端（terminal）是专门为开发人员设计的，用于实现人机交互的一种方式\n\n\n常用终端命令：tab：快速补全文件路径esc：清空当前命令（Ctrl + u）cls：清空当前终端（mac：clear）\n\n4 fs 文件系统模块4.1 什么是 fs 文件系统模块\nfs 模块是 Node.js 官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。例如：• fs.readFile() 方法，用来读取指定文件中的内容• fs.writeFile() 方法，用来向指定的文件中写入内容\n\n如果要在 JavaScript 代码中，使用 fs 模块来操作文件，则需要使用如下的方式先导入它：\nconst fs = require(&quot;fs&quot;);\n\n4.2 fs.readFile()\nfs.readFile(path[, options], callback)参数1：文件的存放路径参数2：读取文件时采用的编码格式，可选，默认 utf8参数3：回调函数，拿到读取成功和失败的结果\n\n/// 1 导入 fs 模块const fs = require(&quot;fs&quot;);// 2 调用 fs.readFile() 读取文件fs.readFile(&quot;./files/1.txt&quot;, &quot;utf8&quot;, (err, dataStr) =&gt; &#123;  // 如果读取成功， err 值为 null  // 如果读取失败， err 值为错误对象， dataStr 值为 undefined  if (err) &#123;    return console.log(&quot;读取文件失败&quot;, err);  &#125;  console.log(&quot;读取文件成功&quot;, dataStr);&#125;);\n\n4.3 fs.writeFile\nfs.writeFile(path, data[, options], callback)参数1：文件的存放路径参数2：要写入的内容参数3：写文件时采用的编码格式，默认 utf8参数4：回调函数，拿到写文件结果\n\n// 1 导入 fs 模块const fs = require(&quot;fs&quot;);// 2 调用 fs.writeFile() 写入文件fs.writeFile(&quot;./files/1.txt&quot;, &quot;写入文件&quot;, (err) =&gt; &#123;  // 如果写入成功，err 值为 null  // 如果写入失败，err 值为 错误对象  if (err) &#123;    return console.log(&quot;写入文件失败&quot;, err);  &#125;  console.log(&quot;写入文件成功&quot;, dataStr);&#125;);\n\n4.4 练习整理前：\n小红=99 小白=100 小黄=70 小黑=66 小绿=88\n整理后：\n小红:99小白:100小黄:70小黑:66小绿:88\n\n\n① 导入需要的fs 文件系統模块② 使用 fs.readFile() 方法，读取素材目录下的 成绩 txt 文件③ 判断文件是否读取失败④ 文件读取成功后，处理成绩数据⑤ 将处理完成的成绩数据，调用 ts.writeFile() 方法，写入到新文件 成绩-before.txt 中\n\nconst fs = require(&quot;fs&quot;);fs.readFile(&quot;./files/成绩.txt&quot;, &quot;utf8&quot;, (err, dataStr) =&gt; &#123;  if (err) &#123;    return console.log(&quot;读取文件失败&quot;);  &#125;  const oldData = dataStr.replaceAll(&quot;=&quot;, &quot;:&quot;).replaceAll(&quot; &quot;, &quot;\\n&quot;);  fs.writeFile(&quot;./files/成绩-after.txt&quot;, oldData, (err) =&gt; &#123;    if (err) &#123;      return console.log(&quot;写入文件失败&quot;);    &#125;    console.log(&quot;写入文件成功&quot;);  &#125;);&#125;);\n\n4.5 路径动态拼接问题在使用 fs 模块操作文件时，如果提供的操作路径是以 .&#x2F;或 ..&#x2F;开头的相对路径时，很容易出现路径动态拼接错误的问题。\n\n原因：代码在运行的时候，会以执行 node 命令时所处的目录，动态拼接出被操作文件的完整路径解决方案：在使用 fs 模块操作文件时，直接提供完整的路径，不要提供 .&#x2F; 或 ..&#x2F;开头的相对路径，从而防止路径动态拼接的问题\n\n// __dirname 表示当前执行脚本所在的目录const fs = require(&quot;fs&quot;);fs.readFile(__dirname + &quot;/files/成绩.txt&quot;, &quot;utf8&quot;);","categories":["技术"],"tags":["Node"]},{"title":"Vue3 + Pinia 持久化存储","url":"/2022/10/09/pinia-plugin-persist/","content":"\n1 前言\n2 持久化存储\n3 高级配置\n\n1 前言\n本文使用 Pinia 及插件 pinia-plugin-persist 做持久化存储，避免修改 store 后还需要手动修改 storage\n本文弃用插件 pinia-plugin-persistedstate，该插件无法配置一个 store 中的变量分别存储于 localStorage 和 sessionStorage\n\n2 持久化存储2.1 安装依赖pnpm i pinia // 安装 piniapnpm i pinia-plugin-persist // 安装持久化存储插件\n\n2.2 新增 store 文件\n新增 store 文件夹\nstore 文件夹下新增 index.ts 文件import type &#123; App &#125; from &#x27;vue&#x27;import &#123; createPinia &#125; from &#x27;pinia&#x27;import piniaPluginPersist from &#x27;pinia-plugin-persist&#x27;const store = createPinia()store.use(piniaPluginPersist)export function setupStore(app: App&lt;Element&gt;) &#123;  app.use(store)&#125;export &#123; store &#125;\n\n2.3 修改 main.ts 文件import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#123; setupStore &#125; from &#x27;./store&#x27;import router from &#x27;./router/routes&#x27;const app = createApp(App)setupStore(app)app.use(router).mount(&#x27;#app&#x27;)\n\n2.4 持久化存储测试\nstore 文件夹下新增 modules 文件夹\nmodules 文件夹下新增 user.ts 文件import &#123; defineStore &#125; from &#x27;pinia&#x27;const userStore = defineStore(&#x27;user&#x27;, &#123;  state: () =&gt; &#123;    return &#123;      accessToken: &#x27;&#x27;,      userName: &#x27;&#x27;    &#125;  &#125;,  actions: &#123;    SET_ACCESS_TOKEN(token: string) &#123;      this.accessToken = token    &#125;,    SET_USER_NAME(name: string) &#123;      this.userName = name    &#125;  &#125;,  persist: &#123;    enabled: true,  &#125;&#125;)export default userStore\n\n若不生效，需检查全局是否注册多个 Pinia （全局搜索createPinia）\n\n比如 main.ts 文件重新注册了 Pinia\nimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#123; createPinia &#125; from &#x27;pinia&#x27;import router from &#x27;./router/routes&#x27;const pinia = createPinia()const app = createApp(App)app.use(pinia)app.use(router).mount(&#x27;#app&#x27;)\n\n3 高级配置3.1 存储所有变量默认存储到 sessionStorage ，key 为 store 的 id\npersist: &#123;  enabled: true&#125;\n存储到 localStorage ，key 为 store 的 id\npersist: &#123;  enabled: true,  strategies: [    &#123;      storage: localStorage,    &#125;,  ]&#125;\n自定义存储 key 值\npersist: &#123;  enabled: true,  strategies: [    &#123;      key: &#x27;piniaStore&#x27;,      storage: localStorage,    &#125;,  ]&#125;\n3.2 存储部分变量默认存储到 sessionStorage\npersist: &#123;  enabled: true,  strategies: [    &#123;      paths: [&#x27;accessToken&#x27;]    &#125;,  ]&#125;\n自定义存储到 localStorage\npersist: &#123;  enabled: true,  strategies: [    &#123;      storage: localStorage,      paths: [&#x27;accessToken&#x27;]    &#125;,  ]&#125;\n自定义存储到 sessionStorage 和 localStorage\npersist: &#123;  enabled: true,  strategies: [    &#123; storage: sessionStorage, paths: [&#x27;userName&#x27;] &#125;,    &#123; storage: localStorage, paths: [&#x27;accessToken&#x27;] &#125;  ]&#125;\n\n","categories":["技术"],"tags":["Vue3","Pinia"]},{"title":"Vue3组合式函数 —— Vue hooks","url":"/2022/09/30/vue3-hooks/","content":"\n1 前言\n2 技术细节\n3 示例\n\n1 前言\n前言摘抄自 Vue.js 官网组合式函数介绍\n\n1.1 什么是“组合式函数”在 Vue 应用的概念中，“组合式函数”(Composables) 是一个利用 Vue 的组合式 API 来封装和复用有状态逻辑的函数。\n1.2 和 Mixin 的对比“组合式函数”和 Vue 2 中的 mixins 功能比较相近，它也让我们能够把组件逻辑提取到可复用的单元里。然而 mixins 有三个主要的短板：\n\n\n不清晰的数据来源：当使用了多个 mixin 时，实例上的数据属性来自哪个 mixin 变得不清晰，这使追溯实现和理解组件行为变得困难。这也是我们推荐在组合式函数中使用 ref + 解构模式的理由：让属性的来源在消费组件时一目了然。\n命名空间冲突：多个来自不同作者的 mixin 可能会注册相同的属性名，造成命名冲突。若使用组合式函数，你可以通过在解构变量时对变量进行重命名来避免相同的键名。\n隐式的跨 mixin 交流：多个 mixin 需要依赖共享的属性名来进行相互作用，这使得它们隐性地耦合在一起。而一个组合式函数的返回值可以作为另一个组合式函数的参数被传入，像普通函数那样。\n\n2 技术细节\n命名规范：组合式函数约定用驼峰命名法命名，并以“use”作为开头\n复用有状态逻辑：变量使用 ref 包裹并抛出\n生命周期钩子：可使用 vue 组件生命周期钩子函数，会先进入组合式函数生命周期，再进入组件内部生命周期\n\n3 示例\n新增 useCustomTab.ts 文件\nimport &#123; ref, onActivated &#125; from &#x27;vue&#x27;export default function () &#123;  const loading = ref(true)  const getData = (isLoading: boolean) =&gt; &#123;    // isLoading：组件传入参数    loading.value = isLoading    setTimeout(() =&gt; &#123;      // 模拟异步接口请求完成后取消 loading      loading.value = false    &#125;, 3000);  &#125;  onActivated(() =&gt; &#123;    getData(true) // 先调用  &#125;)  return &#123;    loading,    getData  &#125;&#125;\n\n在组件中使用\n&lt;template&gt;  &lt;div v-loading=&quot;loading&quot;&gt;    xxx  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import useCustomTab from &#x27;@/hooks/useCustomTab&#x27;const &#123; loading, getData &#125; = useCustomTab()onActivated(() =&gt; &#123;  getData(true) // 后调用&#125;)&lt;/script&gt;\n\n","categories":["技术"],"tags":["Vue3"]},{"title":"qiankun + Vite 实现最简微前端","url":"/2022/09/19/qiankun/","content":"\n1 前言\n2 主应用接入 qiankun\n3 微应用接入 qiankun\n4 应用间通信\n\n1 前言\n前言摘抄自 qiankun 官网微前端介绍\n\n1.1 微前端定义微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(Frontend Monolith)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。\n1.2 微前端架构核心价值\n技术栈无关主框架不限制接入应用的技术栈，微应用具备完全自主权\n独立开发、独立部署微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新\n增量升级在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略\n独立运行时每个微应用之间状态隔离，运行时状态不共享\n\n2 主应用接入 qiankun2.1 安装 qiankunnpm i qiankun\n\n2.2 基于路由配置方式接入\nmain.ts\nimport &#123; registerMicroApps, start &#125; from &#x27;qiankun&#x27;import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;const app = createApp(App)app.use(router)app.mount(&#x27;#app&#x27;)// 注册微应用registerMicroApps(  [    &#123;      name: &#x27;subApp&#x27;, // 必须与微应用注册名字相同      entry: &#x27;http://localhost:8000&#x27;, // 入口路径，开发时为微应用所启本地服务，上线时为微应用线上路径      container: &#x27;#sub-app-container&#x27;, // app.vue 配置的挂载容器 id      activeRule: &#x27;/home&#x27;, // 当访问路由为 home 时加载微应用      props: &#123;        // 主应用向微应用传递参数      &#125;    &#125;  ],  &#123;    // 生命周期钩子函数    // beforeLoad: (app) =&gt; &#123;    //   console.log(&#x27;beforeLoad&#x27;, app)    // &#125;,    // beforeMount: (app) =&gt; &#123;    //   console.log(&#x27;beforeMount &#x27;, app)    // &#125;,    // afterMount: (app) =&gt; &#123;    //   console.log(&#x27;afterMount&#x27;, app)    // &#125;    // beforeUnmount: (app) =&gt; &#123;    //   console.log(&#x27;beforeUnmount &#x27;, app)    // &#125;,    // afterUnmount: (app) =&gt; &#123;    //   console.log(&#x27;afterUnmount&#x27;, app)    // &#125;  &#125;)// 启动 qiankunstart()\n\napp.vue\n&lt;template&gt;  &lt;!-- 提供挂载容器 --&gt;  &lt;div id=&quot;sub-app-container&quot;&gt;&lt;/div&gt;&lt;/template&gt;\n\n2.3 手动加载微应用方式接入\nsubApp.vue&lt;template&gt;  &lt;button @click=&quot;loadApp&quot;&gt;挂载微应用&lt;/button&gt;  &lt;button @click=&quot;unloadApp&quot;&gt;卸载微应用&lt;/button&gt;  &lt;!-- 提供挂载容器 --&gt;  &lt;div id=&quot;sub-app-container&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;import &#123; loadMicroApp &#125; from &#x27;qiankun&#x27;let microApp: any = null // 微应用实例const loadApp = () =&gt; &#123;  if (microApp) return  microApp = loadMicroApp(&#123;    name: &#x27;subApp&#x27;, // 必须与微应用注册名字相同    entry: &#x27;http://localhost:8000&#x27;, // 入口路径，开发时为微应用所启本地服务，上线时为微应用线上路径    container: &#x27;#sub-app-container&#x27;,    props: &#123;      // 主应用向微应用传递参数    &#125;  &#125;)  microApp.mountPromise.then(() =&gt; &#123;    // 微应用加载完成后回调  &#125;)&#125;const unloadApp = () =&gt; &#123;  if (!microApp) return  microApp.unmount() // 卸载微应用&#125;&lt;/script&gt;\n\n3 微应用接入 qiankun3.1 安装 vite-plugin-qiankun\nqiankun 暂不支持 Vite 方式接入，需安装 vite-plugin-qiankun\n\nnpm i vite-plugin-qiankun\n\n3.2 接入 qiankun\nvite.config.ts\nimport &#123; defineConfig &#125; from &#x27;vite&#x27;import qiankun from &#x27;vite-plugin-qiankun&#x27;export default defineConfig((mode) =&gt; &#123;  return &#123;    plugins: [      qiankun(&#x27;subApp&#x27;, &#123; // 微应用名字，与主应用注册的微应用名字保持一致        useDevMode: true,      &#125;),    ],  &#125;&#125;)\n\nmain.ts\nimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#123;  renderWithQiankun,  qiankunWindow,  QiankunProps,&#125; from &#x27;vite-plugin-qiankun/dist/helper&#x27;const render = (props: QiankunProps = &#123;&#125;) =&gt; &#123;  const &#123; container &#125; = props  const app: string | Element = container?.querySelector(&#x27;#subApp&#x27;) || &#x27;#subApp&#x27; // 避免 id 重复导致微应用挂载失败  createApp(App).mount(app)&#125;const initQianKun = () =&gt; &#123;  renderWithQiankun(&#123;    bootstrap() &#123;      console.log(&#x27;微应用：bootstrap&#x27;)    &#125;,    mount(props) &#123; // 获取主应用传入数据      console.log(&#x27;微应用：mount&#x27;, props)      render(props)    &#125;,    unmount(props) &#123;      console.log(&#x27;微应用：unmount&#x27;, props)    &#125;,    update(props) &#123;      console.log(&#x27;微应用：update&#x27;, props)    &#125;,  &#125;)&#125;qiankunWindow.__POWERED_BY_QIANKUN__ ? initQianKun() : render() // 判断是否使用 qiankun ，保证项目可以独立运行\n\n4 应用间通信4.1 全局挂载\nprops 直接传递// 主应用在注册微应用时通过props传参&#123;  name: &#x27;subApp&#x27;, // 必须与微应用注册名字相同  entry: &#x27;http://localhost:8000&#x27;, // 入口路径，开发时为微应用所启本地服务，上线时为微应用线上路径  container: &#x27;#sub-app-container&#x27;, // 挂载容器 id  props: &#123;    // 主应用向微应用传递参数    msg: &#x27;主应用参数&#x27;  &#125;&#125;\nwindow 全局挂载const testFun = () =&gt; &#123;&#125;window[subApp] = &#123; testFun &#125;\n\n4.2 initGlobalState\n该 API 虽然还在官方文档中展示，但 qiankun 源代码中已不推荐使用，但未提供新的通信方案\n\n\n\n主应用新增 actions.ts 文件\nimport &#123; initGlobalState, MicroAppStateActions &#125; from &#x27;qiankun&#x27;const state = &#123;  msg: &#x27;主应用消息&#x27;&#125;// 初始化 stateconst actions: MicroAppStateActions = initGlobalState(state)export default actions\n\nsubApp.vue\n&lt;template&gt;  &lt;button @click=&quot;clickButton&quot;&gt;主应用按钮&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import actions from &#x27;@/actions&#x27;actions.onGlobalStateChange((state, prevState) =&gt; &#123;  console.log(state, prevState)&#125;)const clickButton = () =&gt; &#123;  actions.setGlobalState(&#123;    msg: &#x27;主应用修改主应用消息&#x27;  &#125;)&#125;&lt;/script&gt;\n\n子应用main.ts\nconst initQianKun = () =&gt; &#123;  renderWithQiankun(&#123;    bootstrap() &#123;      console.log(&#x27;微应用：bootstrap&#x27;)    &#125;,    mount(props) &#123; // 获取主应用传入数据      console.log(&#x27;微应用：mount&#x27;, props)      props.actions.setGlobalState(&#123; msg: &#x27;微应用修改主应用消息&#x27; &#125;)      render(props)    &#125;,    unmount(props) &#123;      console.log(&#x27;微应用：unmount&#x27;, props)    &#125;,    update(props) &#123;      console.log(&#x27;微应用：update&#x27;, props)    &#125;,  &#125;)&#125;\n\n","categories":["技术"],"tags":["qiankun","微前端"]},{"title":"Vue3 + Element Plus 多级嵌套菜单动态渲染","url":"/2022/08/30/element-plus-menu/","content":"\n1 前言\n2 sub-menu 组件\n3 menu 组件\n\n1 前言1.1 功能\n动态渲染多级嵌套菜单\n点击菜单跳转页面\n子菜单高亮，对应父级菜单也高亮\n不同路由高亮同一菜单\n\n1.2源码\n地址： https://gitee.com/YanaDH/vue3-element-template/tree/master\n路径： src&#x2F;layout&#x2F;components&#x2F;sidebar&#x2F;menu\n\n2 sub-menu 组件&lt;template&gt;  &lt;el-sub-menu :index=&quot;menu.name&quot; v-if=&quot;menu.childMenu&quot;&gt;    &lt;template #title&gt;      &lt;el-icon&gt;&lt;Menu /&gt;&lt;/el-icon&gt;      &lt;span&gt;&#123;&#123; menu.chineseName &#125;&#125;&lt;/span&gt;    &lt;/template&gt;    &lt;!-- 多级嵌套菜单渲染 --&gt;    &lt;sub-menu :menu=&quot;menuItem&quot; v-for=&quot;menuItem in menu.childMenu&quot; :key=&quot;menuItem.name&quot;&gt;&lt;/sub-menu&gt;  &lt;/el-sub-menu&gt;  &lt;el-menu-item :index=&quot;menu.name&quot; v-else&gt;    &lt;el-icon&gt;&lt;Menu /&gt;&lt;/el-icon&gt;    &lt;template #title&gt;&#123;&#123; menu.chineseName &#125;&#125;&lt;/template&gt;  &lt;/el-menu-item&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;interface Menu &#123;  name: string //菜单唯一标识，与路由名保持一致  chineseName: string //菜单显示名称  childMenu?: Menu[] | undefined //子菜单&#125;defineProps&lt;&#123;  menu: Menu&#125;&gt;()&lt;/script&gt;\n\n3 menu 组件&lt;template&gt;  &lt;el-menu :default-active=&quot;defaultActive&quot; router&gt;    &lt;sub-menu :menu=&quot;menu&quot; v-for=&quot;menu in menuList&quot; :key=&quot;menu.name&quot;&gt;&lt;/sub-menu&gt;  &lt;/el-menu&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; computed &#125; from &#x27;vue&#x27;import &#123; useRoute &#125; from &#x27;vue-router&#x27;import SubMenu from &#x27;./subMenu.vue&#x27;// useRoute().meta?.parentMenu ： 自定义路由点亮菜单，在路由的 meta 上配置 parentMenu 字段，值为父级菜单的 name 值const defaultActive = computed(() =&gt; useRoute().meta?.parentMenu || useRoute().name)const menuList = [  &#123;    name: &#x27;home&#x27;,    chineseName: &#x27;首页&#x27;  &#125;,  &#123;    name: &#x27;literature&#x27;,    chineseName: &#x27;文学&#x27;,    childMenu: [      &#123;        name: &#x27;cartoon&#x27;,        chineseName: &#x27;动漫&#x27;,      &#125;,      &#123;        name: &#x27;essay&#x27;,        chineseName: &#x27;散文随笔&#x27;,        childMenu: [          &#123;            name: &#x27;youth_literature&#x27;,            chineseName: &#x27;青春文学&#x27;,          &#125;        ]      &#125;,      &#123;        name: &#x27;suspenseful_reasoning&#x27;,        chineseName: &#x27;悬疑推理&#x27;,        childMenu: [          &#123;            name: &#x27;history&#x27;,            chineseName: &#x27;历史&#x27;,          &#125;,          &#123;            name: &#x27;noval&#x27;,            chineseName: &#x27;小说&#x27;,            childMenu: [              &#123;                name: &#x27;fiction&#x27;,                chineseName: &#x27;科幻&#x27;,              &#125;,              &#123;                name: &#x27;martial_arts&#x27;,                chineseName: &#x27;武侠&#x27;,              &#125;            ]          &#125;        ]      &#125;    ]  &#125;,  &#123;    name: &#x27;psychology&#x27;,    chineseName: &#x27;心理学&#x27;,  &#125;]&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;// 子菜单高亮，对应父级菜单也高亮.el-menu ::v-deep(.el-sub-menu.is-active &gt; .el-sub-menu__title) &#123;  color: var(--el-color-primary);&#125;&lt;/style&gt;\n","categories":["技术"],"tags":["Element Plus","Vue3"]},{"title":"Vue3 + Element Plus 实现动态标签页及右键菜单","url":"/2022/08/11/element-plus-dropdown/","content":"\n1 前言\n2 生成动态标签页\n3 生成右键菜单\n\n1 前言1.1 目的Tabs 动态标签页实现右键菜单【关闭当前标签页】、【关闭左侧标签页】、【关闭右侧标签页】、【关闭其他标签页】、【关闭全部标签页】功能\n1.2 普通右键菜单网上使用比较多的是v-contextmenu插件实现右键菜单，但该插件对于v-for循环生成的元素失效，插件内部右键菜单显示执行的是emit(&#39;show&#39;)未传入当前元素节点（可能后续会修复），且样式需要自行修改\n1.3 本文右键菜单方式本文使用element-plus自带的el-dropdown实现右键菜单\n2 生成动态标签页2.1 准备变量容器&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;interface TabType &#123;  title: string //标签页显示名称  componentName: string //动态组件名  data: any //动态组件传参&#125;interface TabListType extends TabType &#123;  name: string //标签页唯一标识，添加标签页时根据 componentName 自动生成&#125;const tabList = ref&lt;TabListType[]&gt;([]) //存放标签页数组const tabValue = ref(&#x27;home&#x27;) //存放当前激活标签页，默认激活首页&lt;/script&gt;\n\n2.2 构造标签页\n可动态添加标签页\n除【首页】外，可动态移除标签页&lt;template&gt;  &lt;el-tabs v-model=&quot;tabValue&quot; type=&quot;card&quot; @tab-remove=&quot;removeTab&quot;&gt;    &lt;el-tab-pane label=&quot;首页&quot; name=&quot;home&quot;&gt;      &lt;Home /&gt;    &lt;/el-tab-pane&gt;    &lt;el-tab-pane v-for=&quot;item in tabList&quot; :name=&quot;item.name&quot; :key=&quot;item.name&quot; closable&gt;      &lt;component :is=&quot;item.componentName&quot; v-bind=&quot;item.data&quot;&gt;      &lt;/component&gt;    &lt;/el-tab-pane&gt;  &lt;/el-tabs&gt;&lt;/template&gt;\n\n2.3 动态添加标签页const addTab = (tab: TabType) =&gt; &#123;   //保证相同组件路径标签页 name 标识唯一  const name = `$&#123;tab.componentName&#125;_$&#123;Date.now()&#125;`  tabList.value.push(&#123;    ...tab,    name  &#125;)  tabValue.value = name&#125;addTab(&#123;  title: &#x27;标签1&#x27;,  componentName: &#x27;tag1&#x27;,  data: &#123;    test: &#x27;这是测试数据&#x27;  &#125;&#125;)\n\n2.4 动态移除标签页const removeTab = (targetName: string) =&gt; &#123;  const index = tabList.value.findIndex((item) =&gt; item.name === targetName)  tabList.value.splice(index, 1)  //当前激活标签页与触发右键菜单标签页是同一页  if (targetName === tabValue.value) &#123;    //当前激活标签页是标签页数组的第一个，则将激活标签页设置为 home    //当前激活标签页不是标签页数组的第一个，则将激活标签页设置为当前激活标签页的前一页    tabValue.value = index === 0 ? &#x27;home&#x27; : tabList.value[index - 1].name  &#125;&#125;removeTab(&#x27;tag1&#x27;)\n\n3 生成右键菜单3.1 扩展标签页&lt;template&gt;  &lt;el-tabs v-model=&quot;tabValue&quot; type=&quot;card&quot; @tab-remove=&quot;removeTab&quot;&gt;    &lt;el-tab-pane label=&quot;首页&quot; name=&quot;home&quot;&gt;      &lt;Home /&gt;    &lt;/el-tab-pane&gt;    &lt;el-tab-pane v-for=&quot;item in tabList&quot; :name=&quot;item.name&quot; :key=&quot;item.name&quot; closable&gt;      &lt;!-- 右键菜单开始：自定义标签页显示名称，保证每个标签页都能实现右键菜单 --&gt;      &lt;template #label&gt;        &lt;el-dropdown          trigger=&quot;contextmenu&quot;          :id=&quot;item.name&quot;          @visible-change=&quot;handleChange($event, item.name)&quot;          ref=&quot;dropdownRef&quot;        &gt;          &lt;span :class=&quot;tabValue === item.name ? &#x27;label&#x27; : &#x27;&#x27;&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/span&gt;          &lt;template #dropdown&gt;            &lt;el-dropdown-menu&gt;              &lt;el-dropdown-item @click=&quot;removeTab(item.name)&quot;&gt;                &lt;el-icon&gt;&lt;Close /&gt;&lt;/el-icon&gt;关闭当前标签页              &lt;/el-dropdown-item&gt;              &lt;el-dropdown-item                @click=&quot;removeTab(item.name, &#x27;left&#x27;)&quot;                v-if=&quot;show(item.name, &#x27;left&#x27;)&quot;              &gt;                &lt;el-icon&gt;&lt;DArrowLeft /&gt;&lt;/el-icon&gt;关闭左侧标签页              &lt;/el-dropdown-item&gt;              &lt;el-dropdown-item                @click=&quot;removeTab(item.name, &#x27;right&#x27;)&quot;                v-if=&quot;show(item.name, &#x27;right&#x27;)&quot;              &gt;                &lt;el-icon&gt;&lt;DArrowRight /&gt;&lt;/el-icon&gt;关闭右侧标签页              &lt;/el-dropdown-item&gt;              &lt;el-dropdown-item                @click=&quot;removeTab(item.name, &#x27;other&#x27;)&quot;                v-if=&quot;tabList.length &gt; 1&quot;              &gt;                &lt;el-icon&gt;&lt;Operation /&gt;&lt;/el-icon&gt;关闭其他标签页              &lt;/el-dropdown-item&gt;              &lt;el-dropdown-item @click=&quot;removeTab(item.name, &#x27;all&#x27;)&quot;&gt;                &lt;el-icon&gt;&lt;Minus /&gt;&lt;/el-icon&gt;关闭全部标签页              &lt;/el-dropdown-item&gt;            &lt;/el-dropdown-menu&gt;          &lt;/template&gt;        &lt;/el-dropdown&gt;      &lt;/template&gt;      &lt;!-- 右键菜单结束 --&gt;      &lt;component :is=&quot;item.componentName&quot; v-bind=&quot;item.data&quot;&gt;      &lt;/component&gt;    &lt;/el-tab-pane&gt;  &lt;/el-tabs&gt;&lt;/template&gt;\n\n3.2 增加 show 方法\n触发右键菜单标签页为第一个时，不展示【关闭左侧标签页】\n触发右键菜单标签页为最后一个时，不展示【关闭右侧标签页】const show = (name: string, type: string) =&gt; &#123;  const index = tabList.value.findIndex((item) =&gt; name === item.name)  return type === &#x27;left&#x27; ? index !== 0 : index !== tabList.value.length - 1&#125;\n\n3.3 扩展 removeTab 方法const removeTab = (targetName: string, type?: string) =&gt; &#123;  const index = tabList.value.findIndex((item) =&gt; item.name === targetName) //查找触发右键菜单所在标签页index  const currentIndex = tabList.value.findIndex((item) =&gt; item.name === tabValue.value) //查找当前激活标签页index，存在当前激活标签页与触发右键菜单标签页不是同一个的情况  switch (type) &#123;    case &#x27;all&#x27;: //关闭全部标签页      tabList.value = [] //清空除【首页】外所有标签页      tabValue.value = &#x27;home&#x27; //修改标签激活页      break    case &#x27;other&#x27;: //关闭其他标签页      tabList.value = [tabList.value[index]]      if (targetName !== tabValue.value) &#123;        tabValue.value = targetName      &#125;      break    case &#x27;left&#x27;: //关闭左侧标签页      tabList.value.splice(0, index)      if (currentIndex &lt; index) &#123;        tabValue.value = targetName      &#125;      break    case &#x27;right&#x27;: //关闭右侧标签页      tabList.value.splice(index + 1)      if (currentIndex &gt; index) &#123;        tabValue.value = targetName      &#125;      break    default: //默认关闭当前标签页      tabList.value.splice(index, 1)      //当前激活标签页与触发右键菜单标签页是同一页      if (targetName === tabValue.value) &#123;        //当前激活标签页是标签页数组的第一个，则将激活标签页设置为 home        //当前激活标签页不是标签页数组的第一个，则将激活标签页设置为当前激活标签页的前一页        tabValue.value = index === 0 ? &#x27;home&#x27; : tabList.value[index - 1].name      &#125;      break  &#125;&#125;\n\n3.4 解决重复出现菜单问题\n当连续在多个标签页触发右键时，会出现多个菜单，解决方案为：在触发右键菜单后，关闭其他右键菜单const dropdownRef = ref()const handleChange = (visible: boolean, name: string) =&gt; &#123;  if (!visible) return  dropdownRef.value.forEach((item: &#123; id: string; handleClose: () =&gt; void &#125;) =&gt; &#123;    if (item.id === name) return    item.handleClose()  &#125;)&#125;\n\n3.5 解决自定义标签样式问题&lt;style lang=&quot;scss&quot; scoped&gt;.label &#123;  color: var(--el-color-primary); //激活标签页高亮&#125;:deep(.el-tabs__item) &#123;  &amp;:hover &#123;    span &#123;      color: var(--el-color-primary); //鼠标移到标签页高亮    &#125;  &#125;  .el-dropdown &#123;    line-height: inherit; // 统一标签页显示名称行高  &#125;&#125;&lt;/style&gt;\n","categories":["技术"],"tags":["Element Plus","Vue3"]},{"title":"setTimeout 与 setInterval —— 实现优雅轮询","url":"/2022/07/29/setTimeout/","content":"\n1 定义与用法\n2 setInterval缺陷\n3 优雅轮询\n\n1 定义与用法1.1 setTimeout1.1.1 定义在指定的毫秒数后调用函数或计算表达式\n1.1.2 用法setTimeout(code/function, milliseconds, param1, param2, ...)\n\n1.1.3 技术细节\ncode&#x2F;function\t ：必需，要调用一个代码串，也可以是一个函数\nmilliseconds   ：可选，执行或调用 code&#x2F;function 需要等待的时间，以毫秒计。默认为 0 ，最短为4ms\nparam1, param2 ：可选，传给执行函数的其他参数\n返回值          ：返回一个 ID（数字），可以将这个ID传递给 clearTimeout() 来取消执行const fun = (param1, param2) =&gt; &#123;  console.log(param1, param2);&#125;setTimeout(fun)setTimeout(fun, 1000, &#x27;param1&#x27;, &#x27;param2&#x27;)\n\n1.2 setInterval1.2.1 定义按照指定的周期（以毫秒计）来调用函数或计算表达式\n1.2.2 用法setInterval(code/function, milliseconds, param1, param2, ...)\n\n1.2.3 技术细节\ncode&#x2F;function\t ：必需，要调用一个代码串，也可以是一个函数\nmilliseconds   ：必需，周期性调用 code&#x2F;function 之间的时间间隔，以毫秒计，最短为10ms\nparam1, param2 ：可选，传给执行函数的其他参数\n返回值          ：返回一个 ID（数字），可以将这个ID传递给 clearInterval() 来取消执行const fun = (param1, param2) =&gt; &#123;  console.log(param1, param2);&#125;// setInterval(fun) //milliseconds 参数必须，否则疯狂执行代码块setInterval(fun, 1000, &#x27;param1&#x27;, &#x27;param2&#x27;)\n\n2 setInterval缺陷2.1 无视代码错误即使调用的代码报错了， setInterval 还是会周期性调用代码块\nlet count = 1setInterval(() =&gt; &#123;    count++    console.log(count);    if(count &gt; 3) throw new Error(&#x27;setInterval 报错&#x27;)&#125;, 1000)\n改用 setTimeout\nlet count = 0const fun = () =&gt;&#123;  setTimeout(() =&gt; &#123;    count++    console.log(count);    if(count &gt; 3) throw new Error(&#x27;setTimeout 报错&#x27;)    fun()  &#125;, 1000);&#125;fun()\n\n2.2 无视网络延迟在使用 Ajax 轮询服务器是否有新数据时，如果网络状态不佳，一个接口下发后还没有返回结果，此时 setInterval 还是会周期性调用代码块，导致客户端网络队列塞满 Ajax 请求\nconst http = () =&gt; &#123;  return new Promise((resolve) =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve()    &#125;, 3000);  &#125;)&#125;setInterval(async () =&gt; &#123;    await http()    console.log(&#x27;setInterval&#x27;);&#125;, 1000)\n改用 setTimeout\nconst http = () =&gt; &#123;  return new Promise((resolve) =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve()    &#125;, 3000);  &#125;)&#125;const fun = () =&gt;&#123;  setTimeout(async () =&gt; &#123;    await http();    console.log(&#x27;setTimeout&#x27;);    fun()  &#125;, 1000);&#125;fun()\n\n2.3 不保证间隔执行setInterval 周期性添加执行器到任务队列，如果调用的代码执行的时间大于设置时间间隔，它会跳过调用，这就导致漏执行\n3 优雅轮询递归调用 setTimeout() ，不需要后调用 clearTimeout() 清除定时器\nlet timer = nullconst interval = () =&gt; &#123;  timer = setTimeout(() =&gt; &#123;    // 执行代码块    interval()  &#125;, 1000)&#125;interval()// 清除setTimeout(() =&gt; &#123;  clearTimeout(timer)&#125;, 5000);","categories":["技术"],"tags":["JS"]},{"title":"Vue3 + Element Plus + i18n 国际化","url":"/2022/07/18/i18n/","content":"\n1 前言\n2 vue3 国际化\n3 element plus 国际化\n4 语言切换\n\n1 前言本篇旨在 Vue3 + Element Plus 国际化配置，支持多语言切换\n2 vue3 国际化2.1 安装 vue-i18npnpm i vue-i18n\n\n2.2 新建 locales 文件夹\n以简体中文和英文为例\n\n\n在 src 下新建 locales 文件夹\n在 locales 文件夹下新建 zh-cn.tsexport default &#123;  buttons: &#123;    login: &#x27;登录&#x27;  &#125;,  menus: &#123;    home: &#x27;首页&#x27;  &#125;&#125;\n在 locales 文件夹下新建 en.tsexport default &#123;  buttons: &#123;    login: &#x27;Login&#x27;  &#125;,  menus: &#123;    home: &#x27;Home&#x27;  &#125;&#125;\n在 locales 文件夹下新建 index.tsimport &#123; createI18n &#125; from &#x27;vue-i18n&#x27;import zhCn from &#x27;./zh-cn&#x27;import en from &#x27;./en&#x27;// 创建 i18nconst i18n = createI18n(&#123;  legacy: false,  globalInjection: true, // 全局模式，可以直接使用 $t  locale: localStorage.getItem(&#x27;lang&#x27;) || &#x27;zhCn&#x27;,  messages: &#123;    zhCn,    en  &#125;&#125;)export default i18n\n\n2.3 注册 i18n在 main.ts 文件下注册 i18n\nimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import i18n from &#x27;./locales&#x27;const app = createApp(App)app.use(i18n)app.mount(&#x27;#app&#x27;)\n\n2.4 使用方法2.4.1 在 template 中的使用&#123;&#123; $t(&#x27;menus.home&#x27;) &#125;&#125;\n\n2.4.2 在 ts 中的使用import i18n from &#x27;./locales&#x27;console.log(i18n.global.t(&#x27;menus.home&#x27;))\n\n3 element plus 国际化\nElement Plus 官方提供了一个 Vue 组件 ConfigProvider 用于全局配置国际化的设置el-config-provider 由 Vue3 + Element Plus 按需引入 - 自动导入el-config-provider 手动导入：import { ElConfigProvider } from ‘element-plus’\n\n&lt;template&gt;  &lt;el-config-provider :locale=&quot;useAppStoreHook().locale === &#x27;zhCn&#x27; ? zhCn : en&quot;&gt;    &lt;app /&gt;  &lt;/el-config-provider&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import zhCn from &#x27;element-plus/lib/locale/lang/zh-cn&#x27;import en from &#x27;element-plus/lib/locale/lang/en&#x27;import &#123; useAppStoreHook &#125; from &#x27;@/store/modules/app&#x27; //store存放语言配置&lt;/script&gt;\n\n4 语言切换\n切换语言时，修改 store 、 localstorage 和 i18n 中的语言配置\n\n// store/modules/appimport &#123; defineStore &#125; from &#x27;pinia&#x27;import &#123; store &#125; from &#x27;@/store&#x27;import i18n from &#x27;@/locales&#x27;const useAppStore = defineStore(&#x27;app&#x27;, &#123;  state: () =&gt; &#123;    return &#123;      locale: localStorage.getItem(&#x27;lang&#x27;) || &#x27;zhCn&#x27;    &#125;  &#125;,  actions: &#123;    SET_LOCALE(locale: string) &#123; //语言切换      this.locale = locale      storageLocal.setItem(&#x27;lang&#x27;, locale)      i18n.global.locale.value = locale    &#125;  &#125;&#125;)export function useAppStoreHook() &#123;  return useAppStore(store)&#125;","categories":["技术"],"tags":["Element Plus","Vue3"]},{"title":"Hexo 高级设置","url":"/2022/07/13/hexo-advanced/","content":"\n1 前言\n2 基本使用\n3 网站图标设置\n4 文章末尾打赏功能\n\n1 前言该篇旨在 Hexo 的高级设置，博客搭建请查看Hexo + GitHub 搭建个人博客\n2 基本使用2.1 跳转2.1.1 文章内跳转锚点 [文章内跳转](#目标位置)目标位置 &lt;span id=&quot;目标位置&quot;&gt;&lt;/span&gt;\n2.1.2 不同文章跳转&#123;% post_link 要跳转文章md文件名 %&#125;例：\n&#123;% post_link hexo %&#125;\n效果：\nHexo + GitHub 搭建个人博客\n\n2.2 新增文章模板2.2.1 在 scaffolds 文件夹下新增 post.md---title: &#123;&#123; title &#125;&#125;categories: 技术date: &#123;&#123; date &#125;&#125;tags:---[1. 前言](#前言)## 1 前言\n\n2.2.2 快速生成模板 MD 文件执行hexo new 文件名生成一个md文件\n3 网站图标设置3.1 判断主题是否已提供入口查看主题对应文件夹下的 head.ejs 文件是否有 &lt;link rel=&quot;icon&quot; href=&quot;&quot; /&gt; 标签，有该标签则已提供入口\n3.2 主题已提供入口3.2.1 查看入口标识\n3.2.2 修改主题站点配置文件注意，是修改主题站点配置文件，而不是根目录下的站点配置文件支持本地路径，也支持远程路径\n\n3.3 主题未提供入口3.3.1 制作图标使用比特虫来制作图标 ，也可以直接使用图片\n3.3.2 保存图标将 ico 文件或图片放置到主题对应的的 sources&#x2F;images 文件夹下\n3.3.3 修改 head.ejs 文件&lt;link rel=&quot;icon&quot; href=&quot;&lt;%= url_for(theme.favicon) %&gt;&quot; /&gt;\n\n3.3.4 修改主题站点配置文件favicon: &#x27;/images/favicon.ico&#x27;\n\n4 文章末尾打赏功能4.1 主题自带打赏功能4.1.1 准备收款码将微信、支付宝收款码图片放到主题文件夹下的 images 文件夹里，可以使用草料二维码进行美化\n4.1.2 修改主题站点配置文件#查看主题文档，确定主题是否支持打赏功能，以及打赏对应配置#以 NexT 主题为例reward:  enable: true  comment: 您的鼓励，是我最大的动力！  wechatpay: /images/wechatpay.jpg  alipay: /images/alipay.jpg\n\n4.2 自定义打赏功能4.2.1 准备收款码操作同上\n4.2.2 新增 reward.ejs 文件在主题文件夹下新增 reward.ejs 文件，并将以下内容复制到新增文件中\n&lt;div class=&quot;reward-container&quot;&gt;  &lt;% if(theme.reward.pay_links) &#123; %&gt;  &lt;span class=&quot;reward-button&quot;&gt;&lt;%=theme.reward.title%&gt;&lt;/span&gt;  &lt;div&gt;&lt;%=theme.reward.message%&gt;&lt;/div&gt;  &lt;div class=&quot;reward-pay&quot;&gt;    &lt;% for(const item of theme.reward.pay_links) &#123; %&gt;    &lt;div style=&quot;margin: 10px&quot;&gt;      &lt;img src=&quot;&lt;%= url_for(item.link) %&gt;&quot; alt=&quot;&lt;%= item.type %&gt;&quot; /&gt;    &lt;/div&gt;    &lt;% &#125; %&gt;  &lt;/div&gt;  &lt;% &#125; %&gt;&lt;/div&gt;&lt;script&gt;  const rewardButtonDom = document.getElementsByClassName(&#x27;reward-button&#x27;)[0]  const rewardPayDom = document.getElementsByClassName(&#x27;reward-pay&#x27;)[0]  rewardButtonDom.addEventListener(&#x27;click&#x27;, function () &#123;    rewardPayDom.style.display =      rewardPayDom.style.display === &#x27;flex&#x27; ? &#x27;none&#x27; : &#x27;flex&#x27;  &#125;)&lt;/script&gt;\n\n4.2.3 新增样式文件在主题文件夹下新增 _partial 文件夹，并在新增文件夹里新建 index.styl 、 reward.styl 文件将以下内容复制到 reward.styl\n.reward-container &#123;  margin: 30px 0 20px;  text-align: center;  .reward-button &#123;    display: inline-block;    color: #fff;    background-color: #ec7259;    font-size: 16px;    padding: 8px 16px;    border-radius: 20px;    cursor: pointer;    user-select: none;  &#125;  .reward-pay &#123;    display: none;    flex-wrap: wrap;    justify-content: center;    position: relative;    img &#123;        max-width: 150px;    &#125;  &#125;&#125;\n将以下内容复制到 index.styl\n@import &quot;reward&quot;\n\n4.2.4 注册样式文件在主题文件夹下的 css 文件夹里，找到全局注册样式文件，可能是 main.styl ，也可能是 index.styl ，需要自行判断注册 _partial 样式文件 @import &quot;_partial/index&quot;\n4.2.5 在文章底部插入打赏组件找到项目显示博客文章所对应的 ejs 文件，例如本博客所用主题对应的 ejs 文件是 post.ejs\n\n小窍门：先确定打赏组件在文章中的显示位置，然后复制位置附近的文字全局搜索，快速确定项目显示博客文章所对应的 ejs 文件\n\n将以下内容插入到文件的合适位置\n&lt;% if(theme.reward.enable) &#123; %&gt;  &lt;%- partial(&#x27;_partial/reward&#x27;) %&gt;&lt;% &#125; %&gt;\n\n4.2.6 修改主题站点配置文件将以下内容复制到主题站点配置文件\nreward:  enable: true  title: 赞赏支持  message: 您的鼓励，是我最大的动力！  pay_links:    - &#123; type: 微信, link: /images/wechatpay.png &#125;    - &#123; type: 支付宝, link: /images/alipay.png &#125;\n","categories":["技术"],"tags":["Hexo"]},{"title":"Vue3 + Element Plus 按需引入 - 自动导入","url":"/2022/07/11/element-plus-auto-import/","content":"\n1 前言\n2 准备工作\n3 按需引入\n4 其他\n\n1 前言1.1 目的Element Plus 使用按需引入，大大缩小打包后的文件大小\n1.2 最终效果自动生成 components.d.ts 文件，并在文件中引入 Element Plus 组件自动生成 components.d.ts 文件，并在文件中引入 Element Plus API\n2 准备工作安装 Element Plus\n# 选择一个你喜欢的包管理器# NPM$ npm install element-plus --save# Yarn$ yarn add element-plus# pnpm$ pnpm install element-plus\n3 按需引入3.1 安装插件\n组件按需引入所需插件：unplugin-auto-import 、 unplugin-vue-components\n图标按需引入所需插件：unplugin-auto-import 、 unplugin-icons只需要安装到开发环境\n$ pnpm i unplugin-auto-import unplugin-vue-components unplugin-icons -D\n\n3.2 修改 vite.config.ts 文件\n4 其他4.1 ELMessage 弹框样式未生效\n需手动导入 ElMessage 对应样式，只使用组件 API 导致的样式失效问题可尝试相同处理方法\n// 示例import &#123; ElMessage &#125; from &#x27;element-plus&#x27;import &#x27;element-plus/es/components/message/style/css&#x27;\n\n4.2 图标使用注意，-ep- 是 vite.config.ts 文件中配置的，必须保持一致\n&lt;!-- 直接使用 --&gt;&lt;i-ep-menu /&gt;&lt;!-- 嵌套使用 --&gt;&lt;el-icon&gt;&lt;i-ep-menu /&gt;&lt;/el-icon&gt;\n\n\n\n","categories":["技术"],"tags":["Element Plus","Vue3"]},{"title":"Hexo + GitHub 搭建个人博客","url":"/2022/07/04/hexo/","content":"\n1 前言\n2 准备工作\n3 博客搭建\n4 主题修改\n\n1 前言1.1 目的记录日常开发、学习过程中遇到的问题，方便后续查看\n1.2 最终效果通过网址 https:&#x2F;&#x2F;your username.github.io 直接访问搭建好的博客\n1.3 高级设置该篇旨在博客搭建，高级设置请查看Hexo 高级设置\n2 准备工作2.1 基本环境\nGitHub 账号\nNode.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)\nGit\n\n2.2 创建博客对应的 GitHub 仓库\n仓库名称必须为your username.github.io\n必须为 public 仓库，否则访问博客会404\n下图中我的username是yanadh，那么对应的仓库名称就是yanadh.github.io\n\n3 博客搭建3.1 安装 Hexo$ npm i hexo -g\n\n3.2 初始化$ hexo init\n执行该命令，Hexo 自动下载相关文件到本地\n3.3 预览$ hexo s\n浏览器访问 http://localhost:4000/ ，即可查看本地博客效果，除修改 _config.yml 站点配置文件外，其他文件更改无需重启服务器，可直接刷新查看\n3.4 发布3.4.1 安装插件$ npm i hexo-deployer-git\n\n3.4.2 修改站点配置文件在根目录下找到 _config.yml ，修改最下方 deploy 内容\ndeploy:  type: git  repo: `your username`.github.io 仓库  branch: 分支名例如：deploy:  type: git  repo: git@github.com:YanaDH/yanadh.github.io.git  branch: master\n\n3.4.3 将静态文件推送到 GitHub 仓库$ hexo g -d\n\n执行该命令，生成静态网页文件存放在 public 文件夹下，并推送到 _config.yml 文件 deploy.repo 配置的仓库以上命令执行成功后，浏览器访问 https:&#x2F;&#x2F;your username.github.io ，即可查看博客部署需要时间，若刷新后无效，等待一段时间再试\n\n4 主题修改4.1 下载主题可以在 Hexo 官网上选择一款喜欢的主题，并克隆到 themes 文件夹下\n$ git clone https://github.com/theme-kaze/hexo-theme-kaze.git\n\n4.2 修改站点配置文件在根目录下找到 _config.yml ，修改最下方 theme 内容\ntheme: 主题文件夹名称例如：theme: hexo-theme-Mic_Theme\n\n4.3 修改主题内容可直接到主题对应的 GitHub 提供的文档查看具体修改内容：hexo-theme-Mic_Theme\n","categories":["技术"],"tags":["Hexo","GitHub"]},{"title":"搭建个人脚手架","url":"/2022/07/01/yana-cli/","content":"\n1 前言\n2 目录结构\n3 创建命令\n4 简化命令解析\n5 新增list命令\n6 新增create命令\n7 发布npm包\n8 脚手架优化\n9 自动部署\n\n1 前言1.1 目的使项目快速进入开发阶段，解决万事开头难的问题\n1.2 最终效果通过运行命令，从远端下载代码模板，并能自定义文件夹名称、package.json的部分信息\n2 目录结构GitHubGitee\n├── package.json├── template.json├── node_modules├── bin│   └── yana-cli.js                                     # 命令脚本├── lib│   ├── util│   │   ├── generator.js│   │   └── git-user.js│   ├── create.js                                       # 选择一个模板生成项目│   └── list.js                                         # 查看模板列表\n\n3 创建命令尽量不要使用 Git Bash ，可能会有箭头、颜色等失效问题，直接使用 CMD\n\n3.1 package.json 文件初始化$ npm init --yes\n\n3.2 新建 yana-cli.js\n根目录下新建 bin 文件夹\n在 bin 文件夹下新建 yana-cli.js\n将以下内容粘贴到 yana-cli.js#! usr/bin/env nodeconsole.log(process.argv)\n\n#! usr&#x2F;bin&#x2F;env node ：这行代码不可删除，告诉系统当前脚本由 Node.js 来解析执行\n\n\n\n3.3 添加命令路径在根目录下找到 package.json ，添加 bin 字段\n&quot;bin&quot;: &#123;  &quot;yana-cli&quot;: &quot;bin/yana-cli.js&quot;&#125;\n\n3.4 添加软链接$ npm link\n\n执行该命令，增加软链接到全局，成功后可直接全局使用 yana-cli\n若该命令执行失败，可以在网上查看对应解决方案\n最终无法成功执行，可直接使用 node bin/yana-cli 代替后续 yana-cli 执行命令\n\n3.5 测试命令$ yana-cli\n成功输出以下内容\n[  &#x27;xxx\\xxx\\node.exe&#x27;,  &#x27;xxx\\xxx\\bin\\yana-cli&#x27;]\n\n4 简化命令解析4.1 安装 commander$ npm i commander\n\n4.2 修改 yana-cli.js 文件#! /usr/bin/env nodeconst program = require(&#x27;commander&#x27;)const config = require(&#x27;../package.json&#x27;)program.version(config.version, &#x27;-v, --version&#x27;)// 定义使用方法program  .command(&#x27;create&#x27;)  .description(&#x27;选择模板生成项目&#x27;)  .action(() =&gt; &#123;    require(&#x27;../lib/create&#x27;)  &#125;)program  .command(&#x27;list&#x27;)  .description(&#x27;查看当前可用模板&#x27;)  .action(() =&gt; &#123;    require(&#x27;../lib/list&#x27;)  &#125;)// 解析参数program.parse(process.argv)if (!program.args.length) &#123;  program.help()&#125;\n执行 yana-cli 输出以下内容\n5 新增list命令5.1 新建 list.js 文件\n根目录下新建 lib 文件夹\n在 lib 文件夹下新建 list.js\n将以下内容粘贴到 list.jsconst template = require(&#x27;../template.json&#x27;)console.log(&#x27;当前模板列表如下：\\n&#x27;)console.log(template)\n\n5.2 新建 template.json 文件\n根目录下新建 template.json 文件\n将以下内容粘贴到 template.json&#123;&quot;vue3-project-template&quot;:&quot;https://gitee.com/YanaDH/vue3-project-template.git&quot;&#125;\n执行 yana-cli list 输出以下内容\n\n6 新增create命令6.1 安装插件$ npm i download-git-repo inquirer handlebars\n\ndownload-git-repo ：执行 git clone 克隆模板仓库\ninquirer 根据用户输入内容自定义模板\nhandlebars 替换 package.json 中项目元信息\npackage.json 指的是 template.json 文件配置的vue3-project-template模板仓库里的 package.json 文件，需要被替换的地方需要使用&#123;&#123;&#125;&#125;包裹起来\n\n\n\n\n6.2 新建 create.js\n在 lib 文件夹下新建 create.js\n将以下内容粘贴到 create.jsconst templateUrl = require(&#x27;../template.json&#x27;)[&#x27;vue3-project-template&#x27;]const download = require(&#x27;download-git-repo&#x27;)const inquirer = require(&#x27;inquirer&#x27;)// 新增项const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)const handlebars = require(&#x27;handlebars&#x27;)download(`direct:$&#123;templateUrl&#125;`, &#x27;tmp&#x27;, &#123; clone: true &#125;, (err) =&gt; &#123;  if (err) return  const packagePath = path.join(__dirname, &#x27;../&#x27;, &#x27;/tmp/package.json&#x27;)  const content = JSON.stringify(require(packagePath), &#x27;&#x27;, &#x27;\\t&#x27;)  const template = handlebars.compile(content)  inquirer    .prompt([      &#123; name: &#x27;name&#x27;, message: &#x27;请输入项目名称&#x27; &#125;,      &#123; name: &#x27;description&#x27;, message: &#x27;请输入项目描述&#x27; &#125;,      &#123; name: &#x27;author&#x27;, message: &#x27;请输入项目作者&#x27; &#125;,    ])    .then((params) =&gt; &#123;      const result = template(params)      fs.writeFileSync(packagePath, result)      console.log(params)    &#125;)&#125;)\n\n6.3 create 命令测试$ yana-cli create\n若 inquirer 报错，则降低 inquirer 版本为8.2.4终端输出以下内容对应目录生成 tmp 文件夹，且下载下来的模板仓库 package.json 文件中 name、description、author 为刚刚输入内容\n7 发布npm包若没有npm账号，需要先注册一个\n# 1. 登录npm，输入用户名、密码$ npm login# 2. 发布$ npm publish\n发布成功后可直接通过 npm i yana-cli 进行安装\n8 脚手架优化GitHubGitee\n8.1 安装插件$ npm i chalk ora metalsmith\n\nchalk ：给控制台打印内容添加颜色\nora ：给控制台打印内容添加loading\nmetalsmith ：自定义文件夹名称\n\n8.2 新增 generator.js 文件替换 package.json 文件中的 name、description、author\n\n在 bin 文件夹下 util 文件夹\n在 util 文件夹下新建 generator.js 文件\n将链接内容粘贴到 generator.js\n\n8.3 新增 git-user.js 文件直接将 package.json 文件中的 author 设置为本地 Git 配置的用户名\n\n在 util 文件夹下新建 git-user.js 文件\n将链接内容粘贴到 git-user.js\n\n8.4 修改 create.js 文件中控制台增加颜色、loading等显示将链接内容粘贴到 create.js\n$ yana-cli create\n\n若 ora 报错，则将 ora 版本降为8.2.4\n若 chalk 报错，则将 chalk 版本降为4.1.1\n\n9 自动部署9.1 获取 NPM TOKEN\n在npm生成 NPM TOKEN\n\n\n9.2 配置 NPM TOKEN将 yana-cli 脚手架项目推到 GitHub ，并将生成的 NPM TOKEN 配置到 GitHub 对应仓库\n9.3 添加 Action 脚本\n\n将以下内容粘贴到 mian.yml\n其中NODE_AUTH_TOKEN对应的值secrets.npm_token中npm_token需要与上一步骤配置的NPM TOKEN 名称一致\n当有代码 push 到仓库时， Action 脚本将会自动执行，将包发布到 NPMname: Publish To Npmon:  push:    branches: [ &quot;master&quot; ] jobs:  publish-npm:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v2      - uses: actions/setup-node@v1        with:          node-version: &quot;12.x&quot;          registry-url: https://registry.npmjs.org/      - run: npm publish        env:          NODE_AUTH_TOKEN: $&#123;&#123;secrets.npm_token&#125;&#125;\n\n","categories":["技术"],"tags":["Cli"]}]