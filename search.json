[{"title":"qiankun + Vite 实现最简微前端","url":"/2022/09/19/qiankun/","content":"\n1 前言\n2 主应用接入 qiankun\n3 微应用接入 qiankun\n4 应用间通信\n\n1 前言\n前言摘抄自 qiankun 官网微前端介绍\n\n1.1 微前端定义微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(Frontend Monolith)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。\n1.2 微前端架构核心价值\n技术栈无关主框架不限制接入应用的技术栈，微应用具备完全自主权\n独立开发、独立部署微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新\n增量升级在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略\n独立运行时每个微应用之间状态隔离，运行时状态不共享\n\n2 主应用接入 qiankun2.1 安装 qiankunnpm i qiankun\n\n2.2 基于路由配置方式接入\nmain.ts\nimport &#123; registerMicroApps, start &#125; from &#x27;qiankun&#x27;import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;const app = createApp(App)app.use(router)app.mount(&#x27;#app&#x27;)// 注册微应用registerMicroApps(  [    &#123;      name: &#x27;subApp&#x27;, // 必须与微应用注册名字相同      entry: &#x27;http://localhost:8000&#x27;, // 入口路径，开发时为微应用所启本地服务，上线时为微应用线上路径      container: &#x27;#sub-app-container&#x27;, // app.vue 配置的挂载容器 id      activeRule: &#x27;/home&#x27;, // 当访问路由为 home 时加载微应用      props: &#123;        // 主应用向微应用传递参数      &#125;    &#125;  ],  &#123;    // 生命周期钩子函数    // beforeLoad: (app) =&gt; &#123;    //   console.log(&#x27;beforeLoad&#x27;, app)    // &#125;,    // beforeMount: (app) =&gt; &#123;    //   console.log(&#x27;beforeMount &#x27;, app)    // &#125;,    // afterMount: (app) =&gt; &#123;    //   console.log(&#x27;afterMount&#x27;, app)    // &#125;    // beforeUnmount: (app) =&gt; &#123;    //   console.log(&#x27;beforeUnmount &#x27;, app)    // &#125;,    // afterUnmount: (app) =&gt; &#123;    //   console.log(&#x27;afterUnmount&#x27;, app)    // &#125;  &#125;)// 启动 qiankunstart()\n\napp.vue\n&lt;template&gt;  &lt;!-- 提供挂载容器 --&gt;  &lt;div id=&quot;sub-app-container&quot;&gt;&lt;/div&gt;&lt;/template&gt;\n\n2.3 手动加载微应用方式接入\nsubApp.vue&lt;template&gt;  &lt;button @click=&quot;loadApp&quot;&gt;挂载微应用&lt;/button&gt;  &lt;button @click=&quot;unloadApp&quot;&gt;卸载微应用&lt;/button&gt;  &lt;!-- 提供挂载容器 --&gt;  &lt;div id=&quot;sub-app-container&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;import &#123; loadMicroApp &#125; from &#x27;qiankun&#x27;let microApp: any = null // 微应用实例const loadApp = () =&gt; &#123;  if (microApp) return  microApp = loadMicroApp(&#123;    name: &#x27;subApp&#x27;, // 必须与微应用注册名字相同    entry: &#x27;http://localhost:8000&#x27;, // 入口路径，开发时为微应用所启本地服务，上线时为微应用线上路径    container: &#x27;#sub-app-container&#x27;,    props: &#123;      // 主应用向微应用传递参数    &#125;  &#125;)  microApp.mountPromise.then(() =&gt; &#123;    // 微应用加载完成后回调  &#125;)&#125;const unloadApp = () =&gt; &#123;  if (!microApp) return  microApp.unmount() // 卸载微应用&#125;&lt;/script&gt;\n\n3 微应用接入 qiankun3.1 安装 vite-plugin-qiankun\nqiankun 暂不支持 Vite 方式接入，需安装 vite-plugin-qiankun\n\nnpm i vite-plugin-qiankun\n\n3.2 接入 qiankun\nvite.config.ts\nimport &#123; defineConfig &#125; from &#x27;vite&#x27;import qiankun from &#x27;vite-plugin-qiankun&#x27;export default defineConfig((mode) =&gt; &#123;  return &#123;    plugins: [      qiankun(&#x27;subApp&#x27;, &#123; // 微应用名字，与主应用注册的微应用名字保持一致        useDevMode: true,      &#125;),    ],  &#125;&#125;)\n\nmain.ts\nimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#123;  renderWithQiankun,  qiankunWindow,  QiankunProps,&#125; from &#x27;vite-plugin-qiankun/dist/helper&#x27;const render = (props: QiankunProps = &#123;&#125;) =&gt; &#123;  const &#123; container &#125; = props  const app: string | Element = container?.querySelector(&#x27;#subApp&#x27;) || &#x27;#subApp&#x27; // 避免 id 重复导致微应用挂载失败  createApp(App).mount(app)&#125;const initQianKun = () =&gt; &#123;  renderWithQiankun(&#123;    bootstrap() &#123;      console.log(&#x27;微应用：bootstrap&#x27;)    &#125;,    mount(props) &#123; // 获取主应用传入数据      console.log(&#x27;微应用：mount&#x27;, props)      render(props)    &#125;,    unmount(props) &#123;      console.log(&#x27;微应用：unmount&#x27;, props)    &#125;,    update(props) &#123;      console.log(&#x27;微应用：update&#x27;, props)    &#125;,  &#125;)&#125;qiankunWindow.__POWERED_BY_QIANKUN__ ? initQianKun() : render() // 判断是否使用 qiankun ，保证项目可以独立运行\n\n4 应用间通信4.1 全局挂载\nprops 直接传递// 主应用在注册微应用时通过props传参&#123;  name: &#x27;subApp&#x27;, // 必须与微应用注册名字相同  entry: &#x27;http://localhost:8000&#x27;, // 入口路径，开发时为微应用所启本地服务，上线时为微应用线上路径  container: &#x27;#sub-app-container&#x27;, // 挂载容器 id  props: &#123;    // 主应用向微应用传递参数    msg: &#x27;主应用参数&#x27;  &#125;&#125;\nwindow 全局挂载const testFun = () =&gt; &#123;&#125;window[subApp] = &#123; testFun &#125;\n\n4.2 initGlobalState\n该 API 虽然还在官方文档中展示，但 qiankun 源代码中已不推荐使用，但未提供新的通信方案\n\n\n\n主应用新增 actions.ts 文件\nimport &#123; initGlobalState, MicroAppStateActions &#125; from &#x27;qiankun&#x27;const state = &#123;  msg: &#x27;主应用消息&#x27;&#125;// 初始化 stateconst actions: MicroAppStateActions = initGlobalState(state)export default actions\n\nsubApp.vue\n&lt;template&gt;  &lt;button @click=&quot;clickButton&quot;&gt;主应用按钮&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import actions from &#x27;@/actions&#x27;actions.onGlobalStateChange((state, prevState) =&gt; &#123;  console.log(state, prevState)&#125;)const clickButton = () =&gt; &#123;  actions.setGlobalState(&#123;    msg: &#x27;主应用修改主应用消息&#x27;  &#125;)&#125;&lt;/script&gt;\n\n子应用main.ts\nconst initQianKun = () =&gt; &#123;  renderWithQiankun(&#123;    bootstrap() &#123;      console.log(&#x27;微应用：bootstrap&#x27;)    &#125;,    mount(props) &#123; // 获取主应用传入数据      console.log(&#x27;微应用：mount&#x27;, props)      props.actions.setGlobalState(&#123; msg: &#x27;微应用修改主应用消息&#x27; &#125;)      render(props)    &#125;,    unmount(props) &#123;      console.log(&#x27;微应用：unmount&#x27;, props)    &#125;,    update(props) &#123;      console.log(&#x27;微应用：update&#x27;, props)    &#125;,  &#125;)&#125;\n\n","categories":["技术"],"tags":["微前端","qiankun"]},{"title":"Vue3 + Element Plus 多级嵌套菜单动态渲染","url":"/2022/08/30/element-plus-menu/","content":"\n1 前言\n2 sub-menu 组件\n3 menu 组件\n\n1 前言1.1 功能\n动态渲染多级嵌套菜单\n点击菜单跳转页面\n子菜单高亮，对应父级菜单也高亮\n不同路由高亮同一菜单\n\n1.2源码\n地址： https://gitee.com/YanaDH/vue3-element-template/tree/master\n路径： src&#x2F;layout&#x2F;components&#x2F;sidebar&#x2F;menu\n\n2 sub-menu 组件&lt;template&gt;  &lt;el-sub-menu :index=&quot;menu.name&quot; v-if=&quot;menu.childMenu&quot;&gt;    &lt;template #title&gt;      &lt;el-icon&gt;&lt;Menu /&gt;&lt;/el-icon&gt;      &lt;span&gt;&#123;&#123; menu.chineseName &#125;&#125;&lt;/span&gt;    &lt;/template&gt;    &lt;!-- 多级嵌套菜单渲染 --&gt;    &lt;sub-menu :menu=&quot;menuItem&quot; v-for=&quot;menuItem in menu.childMenu&quot; :key=&quot;menuItem.name&quot;&gt;&lt;/sub-menu&gt;  &lt;/el-sub-menu&gt;  &lt;el-menu-item :index=&quot;menu.name&quot; v-else&gt;    &lt;el-icon&gt;&lt;Menu /&gt;&lt;/el-icon&gt;    &lt;template #title&gt;&#123;&#123; menu.chineseName &#125;&#125;&lt;/template&gt;  &lt;/el-menu-item&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;interface Menu &#123;  name: string //菜单唯一标识，与路由名保持一致  chineseName: string //菜单显示名称  childMenu?: Menu[] | undefined //子菜单&#125;defineProps&lt;&#123;  menu: Menu&#125;&gt;()&lt;/script&gt;\n\n3 menu 组件&lt;template&gt;  &lt;el-menu :default-active=&quot;defaultActive&quot; router&gt;    &lt;sub-menu :menu=&quot;menu&quot; v-for=&quot;menu in menuList&quot; :key=&quot;menu.name&quot;&gt;&lt;/sub-menu&gt;  &lt;/el-menu&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; computed &#125; from &#x27;vue&#x27;import &#123; useRoute &#125; from &#x27;vue-router&#x27;import SubMenu from &#x27;./subMenu.vue&#x27;// useRoute().meta?.parentMenu ： 自定义路由点亮菜单，在路由的 meta 上配置 parentMenu 字段，值为父级菜单的 name 值const defaultActive = computed(() =&gt; useRoute().meta?.parentMenu || useRoute().name)const menuList = [  &#123;    name: &#x27;home&#x27;,    chineseName: &#x27;首页&#x27;  &#125;,  &#123;    name: &#x27;literature&#x27;,    chineseName: &#x27;文学&#x27;,    childMenu: [      &#123;        name: &#x27;cartoon&#x27;,        chineseName: &#x27;动漫&#x27;,      &#125;,      &#123;        name: &#x27;essay&#x27;,        chineseName: &#x27;散文随笔&#x27;,        childMenu: [          &#123;            name: &#x27;youth_literature&#x27;,            chineseName: &#x27;青春文学&#x27;,          &#125;        ]      &#125;,      &#123;        name: &#x27;suspenseful_reasoning&#x27;,        chineseName: &#x27;悬疑推理&#x27;,        childMenu: [          &#123;            name: &#x27;history&#x27;,            chineseName: &#x27;历史&#x27;,          &#125;,          &#123;            name: &#x27;noval&#x27;,            chineseName: &#x27;小说&#x27;,            childMenu: [              &#123;                name: &#x27;fiction&#x27;,                chineseName: &#x27;科幻&#x27;,              &#125;,              &#123;                name: &#x27;martial_arts&#x27;,                chineseName: &#x27;武侠&#x27;,              &#125;            ]          &#125;        ]      &#125;    ]  &#125;,  &#123;    name: &#x27;psychology&#x27;,    chineseName: &#x27;心理学&#x27;,  &#125;]&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;// 子菜单高亮，对应父级菜单也高亮.el-menu ::v-deep(.el-sub-menu.is-active &gt; .el-sub-menu__title) &#123;  color: var(--el-color-primary);&#125;&lt;/style&gt;\n","categories":["技术"],"tags":["Element Plus","Vue3"]},{"title":"Vue3 + Element Plus 实现动态标签页及右键菜单","url":"/2022/08/11/element-plus-dropdown/","content":"\n前言\n生成动态标签页\n生成右键菜单\n\n\n1 前言1.1 目的Tabs 动态标签页实现右键菜单【关闭当前标签页】、【关闭左侧标签页】、【关闭右侧标签页】、【关闭其他标签页】、【关闭全部标签页】功能\n1.2 普通右键菜单网上使用比较多的是v-contextmenu插件实现右键菜单，但该插件对于v-for循环生成的元素失效，插件内部右键菜单显示执行的是emit(&#39;show&#39;)未传入当前元素节点（可能后续会修复），且样式需要自行修改\n1.3 本文右键菜单方式本文使用element-plus自带的el-dropdown实现右键菜单\n\n2 生成动态标签页2.1 准备变量容器&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;interface TabType &#123;  title: string //标签页显示名称  componentName: string //动态组件名  data: any //动态组件传参&#125;interface TabListType extends TabType &#123;  name: string //标签页唯一标识，添加标签页时根据 componentName 自动生成&#125;const tabList = ref&lt;TabListType[]&gt;([]) //存放标签页数组const tabValue = ref(&#x27;home&#x27;) //存放当前激活标签页，默认激活首页&lt;/script&gt;\n\n2.2 构造标签页\n可动态添加标签页\n除【首页】外，可动态移除标签页&lt;template&gt;  &lt;el-tabs v-model=&quot;tabValue&quot; type=&quot;card&quot; @tab-remove=&quot;removeTab&quot;&gt;    &lt;el-tab-pane label=&quot;首页&quot; name=&quot;home&quot;&gt;      &lt;Home /&gt;    &lt;/el-tab-pane&gt;    &lt;el-tab-pane v-for=&quot;item in tabList&quot; :name=&quot;item.name&quot; :key=&quot;item.name&quot; closable&gt;      &lt;component :is=&quot;item.componentName&quot; v-bind=&quot;item.data&quot;&gt;      &lt;/component&gt;    &lt;/el-tab-pane&gt;  &lt;/el-tabs&gt;&lt;/template&gt;\n\n2.3 动态添加标签页const addTab = (tab: TabType) =&gt; &#123;   //保证相同组件路径标签页 name 标识唯一  const name = `$&#123;tab.componentName&#125;_$&#123;Date.now()&#125;`  tabList.value.push(&#123;    ...tab,    name  &#125;)  tabValue.value = name&#125;addTab(&#123;  title: &#x27;标签1&#x27;,  componentName: &#x27;tag1&#x27;,  data: &#123;    test: &#x27;这是测试数据&#x27;  &#125;&#125;)\n\n2.4 动态移除标签页const removeTab = (targetName: string) =&gt; &#123;  const index = tabList.value.findIndex((item) =&gt; item.name === targetName)  tabList.value.splice(index, 1)  //当前激活标签页与触发右键菜单标签页是同一页  if (targetName === tabValue.value) &#123;    //当前激活标签页是标签页数组的第一个，则将激活标签页设置为 home    //当前激活标签页不是标签页数组的第一个，则将激活标签页设置为当前激活标签页的前一页    tabValue.value = index === 0 ? &#x27;home&#x27; : tabList.value[index - 1].name  &#125;&#125;removeTab(&#x27;tag1&#x27;)\n\n\n3 生成右键菜单3.1 扩展标签页&lt;template&gt;  &lt;el-tabs v-model=&quot;tabValue&quot; type=&quot;card&quot; @tab-remove=&quot;removeTab&quot;&gt;    &lt;el-tab-pane label=&quot;首页&quot; name=&quot;home&quot;&gt;      &lt;Home /&gt;    &lt;/el-tab-pane&gt;    &lt;el-tab-pane v-for=&quot;item in tabList&quot; :name=&quot;item.name&quot; :key=&quot;item.name&quot; closable&gt;      &lt;!-- 右键菜单开始：自定义标签页显示名称，保证每个标签页都能实现右键菜单 --&gt;      &lt;template #label&gt;        &lt;el-dropdown          trigger=&quot;contextmenu&quot;          :id=&quot;item.name&quot;          @visible-change=&quot;handleChange($event, item.name)&quot;          ref=&quot;dropdownRef&quot;        &gt;          &lt;span :class=&quot;tabValue === item.name ? &#x27;label&#x27; : &#x27;&#x27;&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/span&gt;          &lt;template #dropdown&gt;            &lt;el-dropdown-menu&gt;              &lt;el-dropdown-item @click=&quot;removeTab(item.name)&quot;&gt;                &lt;el-icon&gt;&lt;Close /&gt;&lt;/el-icon&gt;关闭当前标签页              &lt;/el-dropdown-item&gt;              &lt;el-dropdown-item                @click=&quot;removeTab(item.name, &#x27;left&#x27;)&quot;                v-if=&quot;show(item.name, &#x27;left&#x27;)&quot;              &gt;                &lt;el-icon&gt;&lt;DArrowLeft /&gt;&lt;/el-icon&gt;关闭左侧标签页              &lt;/el-dropdown-item&gt;              &lt;el-dropdown-item                @click=&quot;removeTab(item.name, &#x27;right&#x27;)&quot;                v-if=&quot;show(item.name, &#x27;right&#x27;)&quot;              &gt;                &lt;el-icon&gt;&lt;DArrowRight /&gt;&lt;/el-icon&gt;关闭右侧标签页              &lt;/el-dropdown-item&gt;              &lt;el-dropdown-item                @click=&quot;removeTab(item.name, &#x27;other&#x27;)&quot;                v-if=&quot;tabList.length &gt; 1&quot;              &gt;                &lt;el-icon&gt;&lt;Operation /&gt;&lt;/el-icon&gt;关闭其他标签页              &lt;/el-dropdown-item&gt;              &lt;el-dropdown-item @click=&quot;removeTab(item.name, &#x27;all&#x27;)&quot;&gt;                &lt;el-icon&gt;&lt;Minus /&gt;&lt;/el-icon&gt;关闭全部标签页              &lt;/el-dropdown-item&gt;            &lt;/el-dropdown-menu&gt;          &lt;/template&gt;        &lt;/el-dropdown&gt;      &lt;/template&gt;      &lt;!-- 右键菜单结束 --&gt;      &lt;component :is=&quot;item.componentName&quot; v-bind=&quot;item.data&quot;&gt;      &lt;/component&gt;    &lt;/el-tab-pane&gt;  &lt;/el-tabs&gt;&lt;/template&gt;\n\n3.2 增加 show 方法\n触发右键菜单标签页为第一个时，不展示【关闭左侧标签页】\n触发右键菜单标签页为最后一个时，不展示【关闭右侧标签页】const show = (name: string, type: string) =&gt; &#123;  const index = tabList.value.findIndex((item) =&gt; name === item.name)  return type === &#x27;left&#x27; ? index !== 0 : index !== tabList.value.length - 1&#125;\n\n3.3 扩展 removeTab 方法const removeTab = (targetName: string, type?: string) =&gt; &#123;  const index = tabList.value.findIndex((item) =&gt; item.name === targetName) //查找触发右键菜单所在标签页index  const currentIndex = tabList.value.findIndex((item) =&gt; item.name === tabValue.value) //查找当前激活标签页index，存在当前激活标签页与触发右键菜单标签页不是同一个的情况  switch (type) &#123;    case &#x27;all&#x27;: //关闭全部标签页      tabList.value = [] //清空除【首页】外所有标签页      tabValue.value = &#x27;home&#x27; //修改标签激活页      break    case &#x27;other&#x27;: //关闭其他标签页      tabList.value = [tabList.value[index]]      if (targetName !== tabValue.value) &#123;        tabValue.value = targetName      &#125;      break    case &#x27;left&#x27;: //关闭左侧标签页      tabList.value.splice(0, index)      if (currentIndex &lt; index) &#123;        tabValue.value = targetName      &#125;      break    case &#x27;right&#x27;: //关闭右侧标签页      tabList.value.splice(index + 1)      if (currentIndex &gt; index) &#123;        tabValue.value = targetName      &#125;      break    default: //默认关闭当前标签页      tabList.value.splice(index, 1)      //当前激活标签页与触发右键菜单标签页是同一页      if (targetName === tabValue.value) &#123;        //当前激活标签页是标签页数组的第一个，则将激活标签页设置为 home        //当前激活标签页不是标签页数组的第一个，则将激活标签页设置为当前激活标签页的前一页        tabValue.value = index === 0 ? &#x27;home&#x27; : tabList.value[index - 1].name      &#125;      break  &#125;&#125;\n\n3.4 解决重复出现菜单问题\n当连续在多个标签页触发右键时，会出现多个菜单，解决方案为：在触发右键菜单后，关闭其他右键菜单const dropdownRef = ref()const handleChange = (visible: boolean, name: string) =&gt; &#123;  if (!visible) return  dropdownRef.value.forEach((item: &#123; id: string; handleClose: () =&gt; void &#125;) =&gt; &#123;    if (item.id === name) return    item.handleClose()  &#125;)&#125;\n\n3.5 解决自定义标签样式问题&lt;style lang=&quot;scss&quot; scoped&gt;.label &#123;  color: var(--el-color-primary); //激活标签页高亮&#125;:deep(.el-tabs__item) &#123;  &amp;:hover &#123;    span &#123;      color: var(--el-color-primary); //鼠标移到标签页高亮    &#125;  &#125;  .el-dropdown &#123;    line-height: inherit; // 统一标签页显示名称行高  &#125;&#125;&lt;/style&gt;\n","categories":["技术"],"tags":["Element Plus","Vue3"]},{"title":"setTimeout 与 setInterval —— 实现优雅轮询","url":"/2022/07/29/setTimeout/","content":"\n定义与用法\nsetInterval缺陷\n优雅轮询\n\n\n1 定义与用法1.1 setTimeout1.1.1 定义在指定的毫秒数后调用函数或计算表达式\n1.1.2 用法setTimeout(code/function, milliseconds, param1, param2, ...)\n\n1.1.3 技术细节\ncode&#x2F;function\t ：必需，要调用一个代码串，也可以是一个函数\nmilliseconds   ：可选，执行或调用 code&#x2F;function 需要等待的时间，以毫秒计。默认为 0 ，最短为4ms\nparam1, param2 ：可选，传给执行函数的其他参数\n返回值          ：返回一个 ID（数字），可以将这个ID传递给 clearTimeout() 来取消执行const fun = (param1, param2) =&gt; &#123;  console.log(param1, param2);&#125;setTimeout(fun)setTimeout(fun, 1000, &#x27;param1&#x27;, &#x27;param2&#x27;)\n\n1.2 setInterval1.2.1 定义按照指定的周期（以毫秒计）来调用函数或计算表达式\n1.2.2 用法setInterval(code/function, milliseconds, param1, param2, ...)\n\n1.2.3 技术细节\ncode&#x2F;function\t ：必需，要调用一个代码串，也可以是一个函数\nmilliseconds   ：必需，周期性调用 code&#x2F;function 之间的时间间隔，以毫秒计，最短为10ms\nparam1, param2 ：可选，传给执行函数的其他参数\n返回值          ：返回一个 ID（数字），可以将这个ID传递给 clearInterval() 来取消执行const fun = (param1, param2) =&gt; &#123;  console.log(param1, param2);&#125;// setInterval(fun) //milliseconds 参数必须，否则疯狂执行代码块setInterval(fun, 1000, &#x27;param1&#x27;, &#x27;param2&#x27;)\n\n\n2 setInterval缺陷2.1 无视代码错误即使调用的代码报错了， setInterval 还是会周期性调用代码块\nlet count = 1setInterval(() =&gt; &#123;    count++    console.log(count);    if(count &gt; 3) throw new Error(&#x27;setInterval 报错&#x27;)&#125;, 1000)\n改用 setTimeout\nlet count = 0const fun = () =&gt;&#123;  setTimeout(() =&gt; &#123;    count++    console.log(count);    if(count &gt; 3) throw new Error(&#x27;setTimeout 报错&#x27;)    fun()  &#125;, 1000);&#125;fun()\n\n2.2 无视网络延迟在使用 Ajax 轮询服务器是否有新数据时，如果网络状态不佳，一个接口下发后还没有返回结果，此时 setInterval 还是会周期性调用代码块，导致客户端网络队列塞满 Ajax 请求\nconst http = () =&gt; &#123;  return new Promise((resolve) =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve()    &#125;, 3000);  &#125;)&#125;setInterval(async () =&gt; &#123;    await http()    console.log(&#x27;setInterval&#x27;);&#125;, 1000)\n改用 setTimeout\nconst http = () =&gt; &#123;  return new Promise((resolve) =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve()    &#125;, 3000);  &#125;)&#125;const fun = () =&gt;&#123;  setTimeout(async () =&gt; &#123;    await http();    console.log(&#x27;setTimeout&#x27;);    fun()  &#125;, 1000);&#125;fun()\n\n2.3 不保证间隔执行setInterval 周期性添加执行器到任务队列，如果调用的代码执行的时间大于设置时间间隔，它会跳过调用，这就导致漏执行\n\n3 优雅轮询递归调用 setTimeout() ，不需要后调用 clearTimeout() 清除定时器\nlet timer = nullconst interval = () =&gt; &#123;  timer = setTimeout(() =&gt; &#123;    // 执行代码块    interval()  &#125;, 1000)&#125;interval()// 清除setTimeout(() =&gt; &#123;  clearTimeout(timer)&#125;, 5000);","categories":["技术"],"tags":["JS"]},{"title":"Vue3 + Element Plus + i18n 国际化","url":"/2022/07/18/i18n/","content":"\n1 前言\n2 Vue3 国际化\n3 Element Plus 国际化\n4 语言切换\n\n\n1 前言本篇旨在 Vue3 + Element Plus 国际化配置，支持多语言切换\n\n2 Vue3 国际化2.1 安装 vue-i18npnpm i vue-i18n\n\n2.2 新建 locales 文件夹\n以简体中文和英文为例\n\n\n在 src 下新建 locales 文件夹\n在 locales 文件夹下新建 zh-cn.tsexport default &#123;  buttons: &#123;    login: &#x27;登录&#x27;  &#125;,  menus: &#123;    home: &#x27;首页&#x27;  &#125;&#125;\n在 locales 文件夹下新建 en.tsexport default &#123;  buttons: &#123;    login: &#x27;Login&#x27;  &#125;,  menus: &#123;    home: &#x27;Home&#x27;  &#125;&#125;\n在 locales 文件夹下新建 index.tsimport &#123; createI18n &#125; from &#x27;vue-i18n&#x27;import zhCn from &#x27;./zh-cn&#x27;import en from &#x27;./en&#x27;// 创建 i18nconst i18n = createI18n(&#123;  legacy: false,  globalInjection: true, // 全局模式，可以直接使用 $t  locale: localStorage.getItem(&#x27;lang&#x27;) || &#x27;zhCn&#x27;,  messages: &#123;    zhCn,    en  &#125;&#125;)export default i18n\n\n2.3 注册 i18n在 main.ts 文件下注册 i18n\nimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import i18n from &#x27;./locales&#x27;const app = createApp(App)app.use(i18n)app.mount(&#x27;#app&#x27;)\n\n2.4 使用方法2.4.1 在 template 中的使用&#123;&#123; $t(&#x27;menus.home&#x27;) &#125;&#125;\n\n2.4.2 在 ts 中的使用import i18n from &#x27;./locales&#x27;console.log(i18n.global.t(&#x27;menus.home&#x27;))\n\n\n3 Element Plus 国际化\nElement Plus 官方提供了一个 Vue 组件 ConfigProvider 用于全局配置国际化的设置el-config-provider 由 Vue3 + Element Plus 按需引入 - 自动导入el-config-provider 手动导入：import { ElConfigProvider } from ‘element-plus’\n\n&lt;template&gt;  &lt;el-config-provider :locale=&quot;useAppStoreHook().locale === &#x27;zhCn&#x27; ? zhCn : en&quot;&gt;    &lt;app /&gt;  &lt;/el-config-provider&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import zhCn from &#x27;element-plus/lib/locale/lang/zh-cn&#x27;import en from &#x27;element-plus/lib/locale/lang/en&#x27;import &#123; useAppStoreHook &#125; from &#x27;@/store/modules/app&#x27; //store存放语言配置&lt;/script&gt;\n\n\n4 语言切换\n切换语言时，修改 store 、 localstorage 和 i18n 中的语言配置\n\n// store/modules/appimport &#123; defineStore &#125; from &#x27;pinia&#x27;import &#123; store &#125; from &#x27;@/store&#x27;import i18n from &#x27;@/locales&#x27;const useAppStore = defineStore(&#x27;app&#x27;, &#123;  state: () =&gt; &#123;    return &#123;      locale: localStorage.getItem(&#x27;lang&#x27;) || &#x27;zhCn&#x27;    &#125;  &#125;,  actions: &#123;    SET_LOCALE(locale: string) &#123; //语言切换      this.locale = locale      storageLocal.setItem(&#x27;lang&#x27;, locale)      i18n.global.locale.value = locale    &#125;  &#125;&#125;)export function useAppStoreHook() &#123;  return useAppStore(store)&#125;","categories":["技术"],"tags":["Element Plus","Vue3"]},{"title":"Hexo 高级设置","url":"/2022/07/13/hexo-advanced/","content":"\n前言\n基本使用\n网站图标设置\n文章末尾打赏功能\n\n\n1 前言该篇旨在 Hexo 的高级设置，博客搭建请查看Hexo + GitHub 搭建个人博客\n\n2 基本使用2.1 跳转2.1.1 文章内跳转锚点 [文章内跳转](#目标位置)目标位置 &lt;span id=&quot;目标位置&quot;&gt;&lt;/span&gt;\n2.1.2 不同文章跳转&#123;% post_link 要跳转文章md文件名 %&#125;例：\n&#123;% post_link hexo %&#125;\n效果：\nHexo + GitHub 搭建个人博客\n\n2.2 新增文章模板2.2.1 在 scaffolds 文件夹下新增 post.md---title: &#123;&#123; title &#125;&#125;categories: 技术date: &#123;&#123; date &#125;&#125;tags:---[1. 前言](#前言)&lt;span id=&quot;前言&quot;&gt;&lt;/span&gt;## 1 前言\n\n2.2.2 快速生成模板 MD 文件执行hexo new 文件名生成一个md文件\n\n3 网站图标设置3.1 判断主题是否已提供入口查看主题对应文件夹下的 head.ejs 文件是否有 &lt;link rel=&quot;icon&quot; href=&quot;&quot; /&gt; 标签，有该标签则已提供入口\n3.2 主题已提供入口3.2.1 查看入口标识\n3.2.2 修改主题站点配置文件注意，是修改主题站点配置文件，而不是根目录下的站点配置文件支持本地路径，也支持远程路径\n\n3.3 主题未提供入口3.3.1 制作图标使用比特虫来制作图标 ，也可以直接使用图片\n3.3.2 保存图标将 ico 文件或图片放置到主题对应的的 sources&#x2F;images 文件夹下\n3.3.3 修改 head.ejs 文件&lt;link rel=&quot;icon&quot; href=&quot;&lt;%= url_for(theme.favicon) %&gt;&quot; /&gt;\n\n3.3.4 修改主题站点配置文件favicon: &#x27;/images/favicon.ico&#x27;\n\n\n4 文章末尾打赏功能4.1 主题自带打赏功能4.1.1 准备收款码将微信、支付宝收款码图片放到主题文件夹下的 images 文件夹里，可以使用草料二维码进行美化\n4.1.2 修改主题站点配置文件#查看主题文档，确定主题是否支持打赏功能，以及打赏对应配置#以 NexT 主题为例reward:  enable: true  comment: 您的鼓励，是我最大的动力！  wechatpay: /images/wechatpay.jpg  alipay: /images/alipay.jpg\n\n4.2 自定义打赏功能4.2.1 准备收款码操作同上\n4.2.2 新增 reward.ejs 文件在主题文件夹下新增 reward.ejs 文件，并将以下内容复制到新增文件中\n&lt;div class=&quot;reward-container&quot;&gt;  &lt;% if(theme.reward.pay_links) &#123; %&gt;  &lt;span class=&quot;reward-button&quot;&gt;&lt;%=theme.reward.title%&gt;&lt;/span&gt;  &lt;div&gt;&lt;%=theme.reward.message%&gt;&lt;/div&gt;  &lt;div class=&quot;reward-pay&quot;&gt;    &lt;% for(const item of theme.reward.pay_links) &#123; %&gt;    &lt;div style=&quot;margin: 10px&quot;&gt;      &lt;img src=&quot;&lt;%= url_for(item.link) %&gt;&quot; alt=&quot;&lt;%= item.type %&gt;&quot; /&gt;    &lt;/div&gt;    &lt;% &#125; %&gt;  &lt;/div&gt;  &lt;% &#125; %&gt;&lt;/div&gt;&lt;script&gt;  const rewardButtonDom = document.getElementsByClassName(&#x27;reward-button&#x27;)[0]  const rewardPayDom = document.getElementsByClassName(&#x27;reward-pay&#x27;)[0]  rewardButtonDom.addEventListener(&#x27;click&#x27;, function () &#123;    rewardPayDom.style.display =      rewardPayDom.style.display === &#x27;flex&#x27; ? &#x27;none&#x27; : &#x27;flex&#x27;  &#125;)&lt;/script&gt;\n\n4.2.3 新增样式文件在主题文件夹下新增 _partial 文件夹，并在新增文件夹里新建 index.styl 、 reward.styl 文件将以下内容复制到 reward.styl\n.reward-container &#123;  margin: 30px 0 20px;  text-align: center;  .reward-button &#123;    display: inline-block;    color: #fff;    background-color: #ec7259;    font-size: 16px;    padding: 8px 16px;    border-radius: 20px;    cursor: pointer;    user-select: none;  &#125;  .reward-pay &#123;    display: none;    flex-wrap: wrap;    justify-content: center;    position: relative;    img &#123;        max-width: 150px;    &#125;  &#125;&#125;\n将以下内容复制到 index.styl\n@import &quot;reward&quot;\n\n4.2.4 注册样式文件在主题文件夹下的 css 文件夹里，找到全局注册样式文件，可能是 main.styl ，也可能是 index.styl ，需要自行判断注册 _partial 样式文件 @import &quot;_partial/index&quot;\n4.2.5 在文章底部插入打赏组件找到项目显示博客文章所对应的 ejs 文件，例如本博客所用主题对应的 ejs 文件是 post.ejs\n\n小窍门：先确定打赏组件在文章中的显示位置，然后复制位置附近的文字全局搜索，快速确定项目显示博客文章所对应的 ejs 文件\n\n将以下内容插入到文件的合适位置\n&lt;% if(theme.reward.enable) &#123; %&gt;  &lt;%- partial(&#x27;_partial/reward&#x27;) %&gt;&lt;% &#125; %&gt;\n\n4.2.6 修改主题站点配置文件将以下内容复制到主题站点配置文件\nreward:  enable: true  title: 赞赏支持  message: 您的鼓励，是我最大的动力！  pay_links:    - &#123; type: 微信, link: /images/wechatpay.png &#125;    - &#123; type: 支付宝, link: /images/alipay.png &#125;\n","categories":["技术"],"tags":["Hexo"]},{"title":"Vue3 + Element Plus 按需引入 - 自动导入","url":"/2022/07/11/element-plus-auto-import/","content":"\n前言\n准备工作\n按需引入\n其他\n\n\n1 前言1.1 目的Element Plus 使用按需引入，大大缩小打包后的文件大小\n1.2 最终效果自动生成 components.d.ts 文件，并在文件中引入 Element Plus 组件自动生成 components.d.ts 文件，并在文件中引入 Element Plus API\n\n2 准备工作安装 Element Plus\n# 选择一个你喜欢的包管理器# NPM$ npm install element-plus --save# Yarn$ yarn add element-plus# pnpm$ pnpm install element-plus\n\n3 按需引入3.1 安装插件\n组件按需引入所需插件：unplugin-auto-import 、 unplugin-vue-components\n图标按需引入所需插件：unplugin-auto-import 、 unplugin-icons只需要安装到开发环境\n$ pnpm i unplugin-auto-import unplugin-vue-components unplugin-icons -D\n\n3.2 修改 vite.config.ts 文件\n\n4 其他4.1 ELMessage 弹框样式未生效\n需手动导入 ElMessage 对应样式，只使用组件 API 导致的样式失效问题可尝试相同处理方法\n// 示例import &#123; ElMessage &#125; from &#x27;element-plus&#x27;import &#x27;element-plus/es/components/message/style/css&#x27;\n\n4.2 图标使用注意，-ep- 是 vite.config.ts 文件中配置的，必须保持一致\n&lt;!-- 直接使用 --&gt;&lt;i-ep-menu /&gt;&lt;!-- 嵌套使用 --&gt;&lt;el-icon&gt;&lt;i-ep-menu /&gt;&lt;/el-icon&gt;\n\n\n\n","categories":["技术"],"tags":["Element Plus","Vue3"]},{"title":"Hexo + GitHub 搭建个人博客","url":"/2022/07/04/hexo/","content":"\n前言\n准备工作\n博客搭建\n博客优化\n\n\n1 前言1.1 目的记录日常开发、学习过程中遇到的问题，方便后续查看\n1.2 最终效果通过网址 https:&#x2F;&#x2F;your username.github.io 直接访问搭建好的博客\n1.3 高级设置该篇旨在博客搭建，高级设置请查看Hexo 高级设置\n\n2 准备工作2.1 基本环境\nGitHub 账号\nNode.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)\nGit\n\n2.2 创建博客对应的 GitHub 仓库\n仓库名称必须为your username.github.io\n必须为 public 仓库，否则访问博客会404\n下图中我的username是yanadh，那么对应的仓库名称就是yanadh.github.io\n\n\n3 博客搭建3.1 安装 Hexo$ npm i hexo -g\n\n3.2 初始化$ hexo init\n执行该命令，Hexo 自动下载相关文件到本地\n3.3 预览$ hexo s\n浏览器访问 http://localhost:4000/ ，即可查看本地博客效果，除修改 _config.yml 站点配置文件外，其他文件更改无需重启服务器，可直接刷新查看\n3.4 发布3.4.1 安装插件$ npm i hexo-deployer-git\n\n3.4.2 修改站点配置文件在根目录下找到 _config.yml ，修改最下方 deploy 内容\ndeploy:  type: git  repo: `your username`.github.io 仓库  branch: 分支名例如：deploy:  type: git  repo: git@github.com:YanaDH/yanadh.github.io.git  branch: master\n\n3.4.3 将静态文件推送到 GitHub 仓库$ hexo g -d\n\n执行该命令，生成静态网页文件存放在 public 文件夹下，并推送到 _config.yml 文件 deploy.repo 配置的仓库以上命令执行成功后，浏览器访问 https:&#x2F;&#x2F;your username.github.io ，即可查看博客部署需要时间，若刷新后无效，等待一段时间再试\n\n\n4 主题修改4.1 下载主题可以在 Hexo 官网上选择一款喜欢的主题，并克隆到 themes 文件夹下\n$ git clone https://github.com/theme-kaze/hexo-theme-kaze.git\n\n4.2 修改站点配置文件在根目录下找到 _config.yml ，修改最下方 theme 内容\ntheme: 主题文件夹名称例如：theme: hexo-theme-Mic_Theme\n\n4.3 修改主题内容可直接到主题对应的 GitHub 提供的文档查看具体修改内容：hexo-theme-Mic_Theme\n","categories":["技术"],"tags":["Hexo","GitHub"]},{"title":"搭建个人脚手架","url":"/2022/07/01/yana-cli/","content":"\n前言\n目录结构\n创建命令\n简化命令解析\n新增list命令\n新增create命令\n发布NPM包\n脚手架优化\n自动部署\n\n\n1 前言1.1 目的使项目快速进入开发阶段，解决万事开头难的问题\n1.2 最终效果通过运行命令，从远端下载代码模板，并能自定义文件夹名称、package.json的部分信息\n\n2 目录结构GitHubGitee\n├── package.json├── template.json├── node_modules├── bin│   └── yana-cli.js                                     # 命令脚本├── lib│   ├── util│   │   ├── generator.js│   │   └── git-user.js│   ├── create.js                                       # 选择一个模板生成项目│   └── list.js                                         # 查看模板列表\n\n\n3 创建命令尽量不要使用 Git Bash ，可能会有箭头、颜色等失效问题，直接使用 CMD\n\n3.1 package.json 文件初始化$ npm init --yes\n\n3.2 新建 yana-cli.js\n根目录下新建 bin 文件夹\n在 bin 文件夹下新建 yana-cli.js\n将以下内容粘贴到 yana-cli.js#! usr/bin/env nodeconsole.log(process.argv)\n\n#! usr&#x2F;bin&#x2F;env node ：这行代码不可删除，告诉系统当前脚本由 Node.js 来解析执行\n\n\n\n3.3 添加命令路径在根目录下找到 package.json ，添加 bin 字段\n&quot;bin&quot;: &#123;  &quot;yana-cli&quot;: &quot;bin/yana-cli.js&quot;&#125;\n\n3.4 添加软链接$ npm link\n\n执行该命令，增加软链接到全局，成功后可直接全局使用 yana-cli\n若该命令执行失败，可以在网上查看对应解决方案\n最终无法成功执行，可直接使用 node bin/yana-cli 代替后续 yana-cli 执行命令\n\n3.5 测试命令$ yana-cli\n成功输出以下内容\n[  &#x27;xxx\\xxx\\node.exe&#x27;,  &#x27;xxx\\xxx\\bin\\yana-cli&#x27;]\n\n\n4 简化命令解析4.1 安装 commander$ npm i commander\n\n4.2 修改 yana-cli.js 文件#! /usr/bin/env nodeconst program = require(&#x27;commander&#x27;)const config = require(&#x27;../package.json&#x27;)program.version(config.version, &#x27;-v, --version&#x27;)// 定义使用方法program  .command(&#x27;create&#x27;)  .description(&#x27;选择模板生成项目&#x27;)  .action(() =&gt; &#123;    require(&#x27;../lib/create&#x27;)  &#125;)program  .command(&#x27;list&#x27;)  .description(&#x27;查看当前可用模板&#x27;)  .action(() =&gt; &#123;    require(&#x27;../lib/list&#x27;)  &#125;)// 解析参数program.parse(process.argv)if (!program.args.length) &#123;  program.help()&#125;\n执行 yana-cli 输出以下内容\n\n5 新增list命令5.1 新建 list.js 文件\n根目录下新建 lib 文件夹\n在 lib 文件夹下新建 list.js\n将以下内容粘贴到 list.jsconst template = require(&#x27;../template.json&#x27;)console.log(&#x27;当前模板列表如下：\\n&#x27;)console.log(template)\n\n5.2 新建 template.json 文件\n根目录下新建 template.json 文件\n将以下内容粘贴到 template.json&#123;&quot;vue3-project-template&quot;:&quot;https://gitee.com/YanaDH/vue3-project-template.git&quot;&#125;\n执行 yana-cli list 输出以下内容\n\n\n6 新增create命令6.1 安装插件$ npm i download-git-repo inquirer handlebars\n\ndownload-git-repo ：执行 git clone 克隆模板仓库\ninquirer 根据用户输入内容自定义模板\nhandlebars 替换 package.json 中项目元信息\npackage.json 指的是 template.json 文件配置的vue3-project-template模板仓库里的 package.json 文件，需要被替换的地方需要使用&#123;&#123;&#125;&#125;包裹起来\n\n\n\n\n6.2 新建 create.js\n在 lib 文件夹下新建 create.js\n将以下内容粘贴到 create.jsconst templateUrl = require(&#x27;../template.json&#x27;)[&#x27;vue3-project-template&#x27;]const download = require(&#x27;download-git-repo&#x27;)const inquirer = require(&#x27;inquirer&#x27;)// 新增项const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)const handlebars = require(&#x27;handlebars&#x27;)download(`direct:$&#123;templateUrl&#125;`, &#x27;tmp&#x27;, &#123; clone: true &#125;, (err) =&gt; &#123;  if (err) return  const packagePath = path.join(__dirname, &#x27;../&#x27;, &#x27;/tmp/package.json&#x27;)  const content = JSON.stringify(require(packagePath), &#x27;&#x27;, &#x27;\\t&#x27;)  const template = handlebars.compile(content)  inquirer    .prompt([      &#123; name: &#x27;name&#x27;, message: &#x27;请输入项目名称&#x27; &#125;,      &#123; name: &#x27;description&#x27;, message: &#x27;请输入项目描述&#x27; &#125;,      &#123; name: &#x27;author&#x27;, message: &#x27;请输入项目作者&#x27; &#125;,    ])    .then((params) =&gt; &#123;      const result = template(params)      fs.writeFileSync(packagePath, result)      console.log(params)    &#125;)&#125;)\n\n6.3 create 命令测试$ yana-cli create\n若 inquirer 报错，则降低 inquirer 版本为8.2.4终端输出以下内容对应目录生成 tmp 文件夹，且下载下来的模板仓库 package.json 文件中 name、description、author 为刚刚输入内容\n\n7 发布NPM包若没有npm账号，需要先注册一个\n# 1. 登录npm，输入用户名、密码$ npm login# 2. 发布$ npm publish\n发布成功后可直接通过 npm i yana-cli 进行安装\n\n8 脚手架优化GitHubGitee\n8.1 安装插件$ npm i chalk ora metalsmith\n\nchalk ：给控制台打印内容添加颜色\nora ：给控制台打印内容添加loading\nmetalsmith ：自定义文件夹名称\n\n8.2 新增 generator.js 文件替换 package.json 文件中的 name、description、author\n\n在 bin 文件夹下 util 文件夹\n在 util 文件夹下新建 generator.js 文件\n将链接内容粘贴到 generator.js\n\n8.3 新增 git-user.js 文件直接将 package.json 文件中的 author 设置为本地 Git 配置的用户名\n\n在 util 文件夹下新建 git-user.js 文件\n将链接内容粘贴到 git-user.js\n\n8.4 修改 create.js 文件中控制台增加颜色、loading等显示将链接内容粘贴到 create.js\n$ yana-cli create\n\n若 ora 报错，则将 ora 版本降为8.2.4\n若 chalk 报错，则将 chalk 版本降为4.1.1\n\n\n9 自动部署9.1 获取 NPM TOKEN\n在npm生成 NPM TOKEN\n\n\n9.2 配置 NPM TOKEN将 yana-cli 脚手架项目推到 GitHub ，并将生成的 NPM TOKEN 配置到 GitHub 对应仓库\n9.3 添加 Action 脚本\n\n将以下内容粘贴到 mian.yml\n其中NODE_AUTH_TOKEN对应的值secrets.npm_token中npm_token需要与上一步骤配置的NPM TOKEN 名称一致\n当有代码 push 到仓库时， Action 脚本将会自动执行，将包发布到 NPMname: Publish To Npmon:  push:    branches: [ &quot;master&quot; ] jobs:  publish-npm:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v2      - uses: actions/setup-node@v1        with:          node-version: &quot;12.x&quot;          registry-url: https://registry.npmjs.org/      - run: npm publish        env:          NODE_AUTH_TOKEN: $&#123;&#123;secrets.npm_token&#125;&#125;\n\n","categories":["技术"],"tags":["Cli"]}]